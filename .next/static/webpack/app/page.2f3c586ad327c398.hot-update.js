"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/youtube.ts":
/*!************************!*\
  !*** ./lib/youtube.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchAllVideosByChannel: function() { return /* binding */ fetchAllVideosByChannel; },\n/* harmony export */   fetchComments: function() { return /* binding */ fetchComments; },\n/* harmony export */   fetchLatestChannelComments: function() { return /* binding */ fetchLatestChannelComments; },\n/* harmony export */   fetchVideosByChannel: function() { return /* binding */ fetchVideosByChannel; },\n/* harmony export */   getChannelVideos: function() { return /* binding */ getChannelVideos; },\n/* harmony export */   getCommentReplies: function() { return /* binding */ getCommentReplies; },\n/* harmony export */   getCommentThreads: function() { return /* binding */ getCommentThreads; },\n/* harmony export */   getCommentsForVideo: function() { return /* binding */ getCommentsForVideo; },\n/* harmony export */   mapDbCommentToCommentData: function() { return /* binding */ mapDbCommentToCommentData; },\n/* harmony export */   mapYouTubeCommentToDbComment: function() { return /* binding */ mapYouTubeCommentToDbComment; },\n/* harmony export */   searchForChannel: function() { return /* binding */ searchForChannel; },\n/* harmony export */   updateCommentReplyCounts: function() { return /* binding */ updateCommentReplyCounts; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./lib/utils.ts\");\n\n\n/**\n * YouTube API integration for fetching channel data and comments\n * Based on the YouTube Data API v3 documentation: \n * https://developers.google.com/youtube/v3/docs\n */ /**\n * Searches for a YouTube channel by name\n * @param channelName The name of the channel to search for\n * @param apiKey YouTube API key\n * @returns The channel ID\n */ async function searchForChannel(channelName, apiKey) {\n    const url = \"https://www.googleapis.com/youtube/v3/search?part=snippet&q=\".concat(encodeURIComponent(channelName), \"&type=channel&key=\").concat(apiKey);\n    const response = await fetch(url);\n    const data = await response.json();\n    if (!data.items || data.items.length === 0) {\n        throw new Error(\"Channel not found\");\n    }\n    return data.items[0].id.channelId;\n}\n/**\n * Fetches videos for a YouTube channel\n */ async function fetchVideosByChannel(channelId, apiKey) {\n    let maxResults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50, pageToken = arguments.length > 3 ? arguments[3] : void 0;\n    const url = \"https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=\".concat(channelId, \"&maxResults=\").concat(maxResults, \"&order=date&type=video&key=\").concat(apiKey).concat(pageToken ? \"&pageToken=\".concat(pageToken) : \"\");\n    const response = await fetch(url);\n    return await response.json();\n}\n/**\n * Fetches all videos for a YouTube channel with pagination\n */ async function fetchAllVideosByChannel(channelId, apiKey) {\n    let allVideos = [];\n    let nextPageToken;\n    do {\n        console.log(\"Fetching videos for channel \".concat(channelId).concat(nextPageToken ? \" (page token: \".concat(nextPageToken, \")\") : \"\"));\n        const response = await fetchVideosByChannel(channelId, apiKey, 50, nextPageToken);\n        allVideos = [\n            ...allVideos,\n            ...response.items || []\n        ];\n        nextPageToken = response.nextPageToken;\n        // Add a small delay to avoid API rate limits\n        if (nextPageToken) {\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n        }\n    }while (nextPageToken);\n    return allVideos;\n}\n/**\n * Fetches comments for a specific video\n */ async function fetchComments(videoId, apiKey, pageToken) {\n    try {\n        const url = \"https://www.googleapis.com/youtube/v3/commentThreads?part=snippet,replies&videoId=\".concat(videoId, \"&maxResults=100&key=\").concat(apiKey).concat(pageToken ? \"&pageToken=\".concat(pageToken) : \"\");\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch comments: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching comments:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches the latest comments from a YouTube channel\n */ async function fetchLatestChannelComments(channelId, apiKey) {\n    let maxVideos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, includeOldVideos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, maxComments = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1000, includeReplies = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;\n    // Fetch videos first\n    let videosResponse = await fetchVideosByChannel(channelId, apiKey);\n    let processedVideos = videosResponse.items || [];\n    // If we should include older videos beyond the first page\n    if (includeOldVideos && videosResponse.nextPageToken) {\n        const allVideos = await fetchAllVideosByChannel(channelId, apiKey);\n        processedVideos = allVideos;\n        // Limit to most recent videos\n        if (maxVideos !== -1) {\n            processedVideos = processedVideos.slice(0, maxVideos);\n        }\n    }\n    // Process each video to get comments\n    const allComments = [];\n    let fetchedCommentCount = 0;\n    for (const video of processedVideos){\n        // Skip if we've reached max comments\n        if (maxComments !== -1 && fetchedCommentCount >= maxComments) {\n            break;\n        }\n        try {\n            var _video_id;\n            // Fix: Ensure videoId is properly accessed\n            const videoId = (_video_id = video.id) === null || _video_id === void 0 ? void 0 : _video_id.videoId;\n            if (!videoId) {\n                console.warn(\"Missing videoId for video:\", video);\n                continue;\n            }\n            const commentsResponse = await fetchComments(videoId, apiKey);\n            // Process only top-level comments to start\n            const videoComments = commentsResponse.items || [];\n            for (const commentThread of videoComments){\n                var _commentThread_snippet_topLevelComment, _commentThread_snippet, _video_snippet, _commentThread_replies;\n                if (!(commentThread === null || commentThread === void 0 ? void 0 : (_commentThread_snippet = commentThread.snippet) === null || _commentThread_snippet === void 0 ? void 0 : (_commentThread_snippet_topLevelComment = _commentThread_snippet.topLevelComment) === null || _commentThread_snippet_topLevelComment === void 0 ? void 0 : _commentThread_snippet_topLevelComment.snippet)) {\n                    console.warn(\"Malformed comment thread:\", commentThread);\n                    continue;\n                }\n                const snippet = commentThread.snippet.topLevelComment.snippet;\n                // Add to our list\n                allComments.push({\n                    id: commentThread.id,\n                    videoId: videoId,\n                    videoTitle: ((_video_snippet = video.snippet) === null || _video_snippet === void 0 ? void 0 : _video_snippet.title) || \"Unknown Video\",\n                    authorName: snippet.authorDisplayName,\n                    authorProfileUrl: snippet.authorProfileImageUrl,\n                    text: snippet.textDisplay,\n                    likeCount: snippet.likeCount,\n                    publishedAt: snippet.publishedAt,\n                    updatedAt: snippet.updatedAt || snippet.publishedAt,\n                    totalReplyCount: commentThread.snippet.totalReplyCount || 0,\n                    replies: [] // Initialize empty array for replies\n                });\n                fetchedCommentCount++;\n                // Add replies if there are any and we want them\n                if (includeReplies && ((_commentThread_replies = commentThread.replies) === null || _commentThread_replies === void 0 ? void 0 : _commentThread_replies.comments)) {\n                    for (const reply of commentThread.replies.comments){\n                        var _video_snippet1;\n                        if (!(reply === null || reply === void 0 ? void 0 : reply.snippet)) {\n                            console.warn(\"Malformed reply:\", reply);\n                            continue;\n                        }\n                        allComments.push({\n                            id: reply.id,\n                            videoId: videoId,\n                            videoTitle: ((_video_snippet1 = video.snippet) === null || _video_snippet1 === void 0 ? void 0 : _video_snippet1.title) || \"Unknown Video\",\n                            authorName: reply.snippet.authorDisplayName,\n                            authorProfileUrl: reply.snippet.authorProfileImageUrl,\n                            text: reply.snippet.textDisplay,\n                            likeCount: reply.snippet.likeCount || 0,\n                            publishedAt: reply.snippet.publishedAt,\n                            updatedAt: reply.snippet.updatedAt || reply.snippet.publishedAt,\n                            totalReplyCount: 0,\n                            parentId: commentThread.id,\n                            replies: []\n                        });\n                        fetchedCommentCount++;\n                    }\n                }\n                // Check if we've reached the max\n                if (maxComments !== -1 && fetchedCommentCount >= maxComments) {\n                    break;\n                }\n            }\n        } catch (error) {\n            var _video_id1;\n            // Just log and continue with next video\n            console.error(\"Error fetching comments for video \".concat((_video_id1 = video.id) === null || _video_id1 === void 0 ? void 0 : _video_id1.videoId, \":\"), error);\n        }\n    }\n    return allComments;\n}\n/**\n * Get YouTube comments for a video\n */ async function getCommentsForVideo(videoId, apiKey) {\n    let maxComments = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, includeReplies = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n    console.log(\"Getting comments for video \".concat(videoId, \", including replies: \").concat(includeReplies));\n    let comments = []; // Using Record<string, any> for flexibility\n    let nextPageToken;\n    let commentCount = 0;\n    do {\n        console.log(\"Fetching comments page \".concat(commentCount > 0 ? commentCount / 20 + 1 : 1));\n        const response = await fetchComments(videoId, apiKey, nextPageToken);\n        const videoComments = response.items || [];\n        // Process each top-level comment\n        for (const comment of videoComments){\n            var _comment_replies;\n            comments.push(comment);\n            commentCount++;\n            // Process replies if available and requested\n            if (includeReplies && ((_comment_replies = comment.replies) === null || _comment_replies === void 0 ? void 0 : _comment_replies.comments)) {\n                console.log(\"Found \".concat(comment.replies.comments.length, \" replies for comment \").concat(comment.id));\n                for (const reply of comment.replies.comments){\n                    // Ensure the reply has a properly formatted parent_id\n                    const replyComment = {\n                        ...reply,\n                        snippet: {\n                            ...reply.snippet,\n                            parentId: comment.id,\n                            videoId: videoId // Ensure videoId is included\n                        }\n                    };\n                    comments.push(replyComment);\n                    commentCount++;\n                }\n            }\n        }\n        nextPageToken = response.nextPageToken;\n        // Continue until we've reached max comments or run out of pages\n        if (maxComments !== -1 && commentCount >= maxComments) {\n            console.log(\"Reached maximum of \".concat(maxComments, \" comments\"));\n            break;\n        }\n        // Small delay to avoid rate limiting\n        if (nextPageToken) {\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n        }\n    }while (nextPageToken);\n    console.log(\"Retrieved \".concat(comments.length, \" comments total\"));\n    return comments;\n}\n// Updated mapYouTubeCommentToDbComment function with more robust type checking\nfunction mapYouTubeCommentToDbComment(comment, channelId) {\n    var _comment_snippet, _comment_snippet_topLevelComment, _comment_snippet1, _comment_snippet2, _comment_snippet3, _comment_snippet_topLevelComment1, _comment_snippet4;\n    // Very explicitly extract parentId from all possible locations\n    let parentId = null;\n    // First check if it's in snippet.parentId\n    if ((_comment_snippet = comment.snippet) === null || _comment_snippet === void 0 ? void 0 : _comment_snippet.parentId) {\n        parentId = comment.snippet.parentId;\n        console.log(\"Found parentId in snippet.parentId: \".concat(parentId));\n    } else if (((_comment_snippet1 = comment.snippet) === null || _comment_snippet1 === void 0 ? void 0 : (_comment_snippet_topLevelComment = _comment_snippet1.topLevelComment) === null || _comment_snippet_topLevelComment === void 0 ? void 0 : _comment_snippet_topLevelComment.id) && comment.id !== comment.snippet.topLevelComment.id) {\n        parentId = comment.snippet.topLevelComment.id;\n        console.log(\"Found parentId from topLevelComment: \".concat(parentId));\n    }\n    // If this is a direct API reply, it might be structured differently\n    if (((_comment_snippet2 = comment.snippet) === null || _comment_snippet2 === void 0 ? void 0 : _comment_snippet2.type) === \"reply\" && ((_comment_snippet3 = comment.snippet) === null || _comment_snippet3 === void 0 ? void 0 : _comment_snippet3.parentId)) {\n        parentId = comment.snippet.parentId;\n        console.log(\"Found parentId from reply type: \".concat(parentId));\n    }\n    // Log mapping for debugging\n    console.log(\"Mapping comment \".concat(comment.id, \", parentId: \").concat(parentId || \"NONE (top-level)\"));\n    // Ensure we have proper access to all required properties\n    const topLevelSnippet = (_comment_snippet4 = comment.snippet) === null || _comment_snippet4 === void 0 ? void 0 : (_comment_snippet_topLevelComment1 = _comment_snippet4.topLevelComment) === null || _comment_snippet_topLevelComment1 === void 0 ? void 0 : _comment_snippet_topLevelComment1.snippet;\n    const directSnippet = comment.snippet;\n    return {\n        comment_id: comment.id,\n        video_id: directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.videoId,\n        author_name: (topLevelSnippet === null || topLevelSnippet === void 0 ? void 0 : topLevelSnippet.authorDisplayName) || (directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.authorDisplayName),\n        author_profile_url: (topLevelSnippet === null || topLevelSnippet === void 0 ? void 0 : topLevelSnippet.authorProfileImageUrl) || (directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.authorProfileImageUrl),\n        text: (topLevelSnippet === null || topLevelSnippet === void 0 ? void 0 : topLevelSnippet.textDisplay) || (directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.textDisplay),\n        like_count: (topLevelSnippet === null || topLevelSnippet === void 0 ? void 0 : topLevelSnippet.likeCount) || (directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.likeCount) || 0,\n        published_at: (topLevelSnippet === null || topLevelSnippet === void 0 ? void 0 : topLevelSnippet.publishedAt) || (directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.publishedAt),\n        channel_id: channelId,\n        is_owner_comment: false,\n        parent_id: parentId,\n        video_title: (directSnippet === null || directSnippet === void 0 ? void 0 : directSnippet.videoTitle) || \"\"\n    };\n}\n// Enhanced mapping function that handles all possible properties\nfunction mapDbCommentToCommentData(dbComment) {\n    return {\n        id: dbComment.comment_id,\n        authorDisplayName: dbComment.author_name || \"Unknown User\",\n        authorProfileImageUrl: dbComment.author_profile_url || \"https://www.gravatar.com/avatar/?d=mp\",\n        textDisplay: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.decodeAllHtmlEntities)(dbComment.text || \"\"),\n        likeCount: dbComment.like_count || 0,\n        publishedAt: dbComment.published_at,\n        updatedAt: dbComment.updated_at || dbComment.published_at,\n        videoId: dbComment.video_id,\n        videoTitle: dbComment.video_title || \"\",\n        replyCount: dbComment.reply_count || 0,\n        isHeartedByCreator: false,\n        isPinned: false,\n        parentId: dbComment.parent_id,\n        replies: [] // Will be populated separately if needed\n    };\n}\n// Debug function to inspect parent-child relationships in the database\nfunction logAllParentChildRelationships() {\n    return _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"comment_id, parent_id\").not(\"parent_id\", \"is\", null).limit(20).then((param)=>{\n        let { data, error } = param;\n        console.log(\"\\uD83D\\uDD0D PARENT-CHILD DEBUG - Sample comments with parents:\", data);\n        console.log(\"Error if any:\", error);\n        return data;\n    });\n}\n// Modified getCommentReplies function to fix reply lookup\nasync function getCommentReplies(commentId) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCommentReplies - Looking for replies to commentId:\", commentId);\n        // First, check if any comments in the database have parent_id matching our commentId\n        const { data: replyCheck, error: replyCheckError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"count(*)\").eq(\"parent_id\", commentId).single();\n        console.log(\"\\uD83D\\uDCCA getCommentReplies - Reply check result:\", replyCheck);\n        if (replyCheckError) {\n            console.error(\"❌ Reply check error:\", replyCheckError);\n        }\n        // Check the actual comment we're looking for replies to\n        const { data: parentComment, error: parentError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\").eq(\"comment_id\", commentId).single();\n        if (parentComment) {\n            var _parentComment_text;\n            console.log(\"✅ Found parent comment:\", {\n                id: parentComment.id,\n                comment_id: parentComment.comment_id,\n                video_id: parentComment.video_id,\n                text: ((_parentComment_text = parentComment.text) === null || _parentComment_text === void 0 ? void 0 : _parentComment_text.substring(0, 50)) + \"...\" || 0\n            });\n        } else {\n            console.log(\"⚠️ Parent comment not found for ID:\", commentId);\n        }\n        // Search for replies directly \n        const { data: replies, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\").eq(\"parent_id\", commentId) // This assumes parent_id references comment_id \n        .order(\"published_at\", {\n            ascending: true\n        });\n        if (error) {\n            console.error(\"❌ Error fetching replies:\", error);\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCCA Found \".concat((replies === null || replies === void 0 ? void 0 : replies.length) || 0, \" replies for comment:\"), commentId);\n        if (replies && replies.length > 0) {\n            var _replies__text;\n            // Sample the first reply\n            console.log(\"\\uD83D\\uDD0D First reply sample:\", {\n                id: replies[0].id,\n                comment_id: replies[0].comment_id,\n                parent_id: replies[0].parent_id,\n                video_id: replies[0].video_id,\n                text: ((_replies__text = replies[0].text) === null || _replies__text === void 0 ? void 0 : _replies__text.substring(0, 50)) + \"...\" || 0\n            });\n        }\n        // Map to the expected format\n        const replyData = (replies === null || replies === void 0 ? void 0 : replies.map((reply)=>mapDbCommentToCommentData(reply))) || [];\n        return replyData;\n    } catch (error) {\n        console.error(\"❌ Error in getCommentReplies:\", error);\n        return [];\n    }\n}\n// Get videos for a channel\nasync function getChannelVideos(channelId) {\n    try {\n        // Step 1: Get the internal UUID for this YouTube channel ID\n        const { data: channel } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"channels\").select(\"id\").eq(\"channel_id\", channelId).single();\n        if (!channel) {\n            console.log(\"Channel not found with ID:\", channelId);\n            return [];\n        }\n        console.log(\"Found channel, internal ID:\", channel.id);\n        // Step 2: Use the internal UUID to query videos\n        const { data: videos, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"videos\").select(\"*\").eq(\"channel_id\", channel.id); // Using internal UUID instead of YouTube channel ID\n        if (error) {\n            console.error(\"Error fetching videos:\", error);\n            throw error;\n        }\n        if (!videos || videos.length === 0) {\n            return [];\n        }\n        // Map DB videos to VideoData format\n        const videoData = videos.map((video)=>({\n                id: video.video_id,\n                title: video.title || \"Untitled Video\",\n                description: video.description || \"\",\n                publishedAt: video.published_at,\n                thumbnailUrl: video.thumbnail_url || \"\",\n                channelId: video.channel_id\n            }));\n        return videoData;\n    } catch (error) {\n        console.error(\"Error in getChannelVideos:\", error);\n        return [];\n    }\n}\n// Add this function to inspect a comment record\nfunction inspectComment(comment) {\n    console.log(\"Comment structure:\", {\n        id: comment.id,\n        comment_id: comment.comment_id,\n        video_id: comment.video_id,\n        parent_id: comment.parent_id,\n        channel_id: comment.channel_id\n    });\n}\n// Update the getCommentThreads function with additional debugging\nasync function getCommentThreads(channelId, videoId) {\n    let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, perPage = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 20;\n    try {\n        console.log(\"\\uD83D\\uDD0E getCommentThreads - Inputs:\", {\n            channelId,\n            videoId,\n            page,\n            perPage\n        });\n        // Step 1: Get the internal UUID for this YouTube channel ID\n        const { data: channel, error: channelError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"channels\").select(\"*\").eq(\"channel_id\", channelId).single();\n        if (channelError) {\n            console.error(\"❌ getCommentThreads - Error finding channel:\", channelError);\n            return [];\n        }\n        if (!channel) {\n            console.log(\"⚠️ getCommentThreads - Channel not found with ID:\", channelId);\n            return [];\n        }\n        console.log(\"✅ getCommentThreads - Found channel:\", {\n            internal_id: channel.id,\n            channel_id: channel.channel_id,\n            title: channel.title\n        });\n        // Step 2: Use the internal UUID to query comments\n        const startIdx = (page - 1) * perPage;\n        const endIdx = page * perPage - 1;\n        console.log(\"\\uD83D\\uDD22 getCommentThreads - Range: \".concat(startIdx, \" to \").concat(endIdx));\n        let query = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\").eq(\"channel_id\", channel.id).is(\"parent_id\", null) // Only get top-level comments\n        .order(\"published_at\", {\n            ascending: false\n        }).range(startIdx, endIdx);\n        if (videoId) {\n            query = query.eq(\"video_id\", videoId);\n        }\n        const { data: comments, error: commentsError } = await query;\n        if (commentsError) {\n            console.error(\"❌ getCommentThreads - Error fetching comments:\", commentsError);\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCCA getCommentThreads - Found \".concat((comments === null || comments === void 0 ? void 0 : comments.length) || 0, \" comments\"));\n        if (!comments || comments.length === 0) {\n            return [];\n        }\n        // Sample the first comment to debug\n        if (comments.length > 0) {\n            console.log(\"\\uD83D\\uDD0D getCommentThreads - First comment:\", {\n                id: comments[0].id,\n                comment_id: comments[0].comment_id,\n                parent_id: comments[0].parent_id,\n                channel_id: comments[0].channel_id\n            });\n        }\n        // For each comment, count replies and map to CommentData format\n        const commentData = await Promise.all(comments.map(async (comment)=>{\n            // Count replies for this comment \n            const { count } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"parent_id\", comment.comment_id);\n            const replyCount = count || 0;\n            // Map DB comment to CommentData format with reply count\n            return {\n                ...mapDbCommentToCommentData(comment),\n                replyCount\n            };\n        }));\n        return commentData;\n    } catch (error) {\n        console.error(\"❌ getCommentThreads - Unhandled error:\", error);\n        return [];\n    }\n}\nasync function updateCommentReplyCounts() {\n    console.log(\"Updating reply counts for all comments...\");\n    try {\n        // For each comment with replies, count them and update the reply_count\n        const { data: comments } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"comment_id\").is(\"parent_id\", null);\n        if (!comments) return;\n        for (const comment of comments){\n            // Count the replies for this comment\n            const { count } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"parent_id\", comment.comment_id);\n            // Update the reply_count\n            if (count !== undefined) {\n                await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").update({\n                    reply_count: count\n                }).eq(\"comment_id\", comment.comment_id);\n            }\n        }\n        console.log(\"Reply counts updated successfully\");\n    } catch (error) {\n        console.error(\"Error updating reply counts:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi95b3V0dWJlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU3NDO0FBRThCO0FBRXBFOzs7O0NBSUMsR0FFRDs7Ozs7Q0FLQyxHQUNNLGVBQWVFLGlCQUFpQkMsV0FBbUIsRUFBRUMsTUFBYztJQUN4RSxNQUFNQyxNQUFNLCtEQUFtSEQsT0FBcERFLG1CQUFtQkgsY0FBYSxzQkFBMkIsT0FBUEM7SUFDL0gsTUFBTUcsV0FBVyxNQUFNQyxNQUFNSDtJQUM3QixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7SUFFaEMsSUFBSSxDQUFDRCxLQUFLRSxLQUFLLElBQUlGLEtBQUtFLEtBQUssQ0FBQ0MsTUFBTSxLQUFLLEdBQUc7UUFDMUMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsT0FBT0osS0FBS0UsS0FBSyxDQUFDLEVBQUUsQ0FBQ0csRUFBRSxDQUFDQyxTQUFTO0FBQ25DO0FBRUE7O0NBRUMsR0FDTSxlQUFlQyxxQkFDcEJELFNBQWlCLEVBQ2pCWCxNQUFjO1FBQ2RhLGFBQUFBLGlFQUFxQixJQUNyQkM7SUFFQSxNQUFNYixNQUFNLHVFQUErRlksT0FBeEJGLFdBQVUsZ0JBQXNEWCxPQUF4Q2EsWUFBVywrQkFBc0NDLE9BQVRkLFFBQW9ELE9BQTNDYyxZQUFZLGNBQXdCLE9BQVZBLGFBQWM7SUFDcE0sTUFBTVgsV0FBVyxNQUFNQyxNQUFNSDtJQUM3QixPQUFPLE1BQU1FLFNBQVNHLElBQUk7QUFDNUI7QUFFQTs7Q0FFQyxHQUNNLGVBQWVTLHdCQUNwQkosU0FBaUIsRUFDakJYLE1BQWM7SUFFZCxJQUFJZ0IsWUFBNEIsRUFBRTtJQUNsQyxJQUFJQztJQUVKLEdBQUc7UUFDREMsUUFBUUMsR0FBRyxDQUFDLCtCQUEyQ0YsT0FBWk4sV0FBbUUsT0FBdkRNLGdCQUFnQixpQkFBK0IsT0FBZEEsZUFBYyxPQUFLO1FBQzNHLE1BQU1kLFdBQVcsTUFBTVMscUJBQXFCRCxXQUFXWCxRQUFRLElBQUlp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QixJQUFJeUQsVUFBVUcsV0FBVztnQkFDdkIsTUFBTXRJLCtDQUFRQSxDQUNYNEYsSUFBSSxDQUFDLFlBQ0wyQyxNQUFNLENBQUM7b0JBQUUvQyxhQUFhMkM7Z0JBQU0sR0FDNUI5QixFQUFFLENBQUMsY0FBY2pDLFFBQVFNLFVBQVU7WUFDeEM7UUFDRjtRQUVBcEQsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPUSxPQUFPO1FBQ2RULFFBQVFTLEtBQUssQ0FBQyxnQ0FBZ0NBO0lBQ2hEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3lvdXR1YmUudHM/MzIyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgWW91VHViZUNoYW5uZWwsIFxuICBZb3VUdWJlVmlkZW8sIFxuICBZb3VUdWJlQ29tbWVudCxcbiAgWW91VHViZUNoYW5uZWxSZXNwb25zZSxcbiAgWW91VHViZVZpZGVvUmVzcG9uc2UsXG4gIFlvdVR1YmVDb21tZW50UmVzcG9uc2UsXG4gIERiQ29tbWVudCBcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJy4vc3VwYWJhc2UnO1xuaW1wb3J0IHsgQ29tbWVudERhdGEsIFZpZGVvRGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZGVjb2RlSHRtbEVudGl0aWVzLCBkZWNvZGVBbGxIdG1sRW50aXRpZXMgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBZb3VUdWJlIEFQSSBpbnRlZ3JhdGlvbiBmb3IgZmV0Y2hpbmcgY2hhbm5lbCBkYXRhIGFuZCBjb21tZW50c1xuICogQmFzZWQgb24gdGhlIFlvdVR1YmUgRGF0YSBBUEkgdjMgZG9jdW1lbnRhdGlvbjogXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL3YzL2RvY3NcbiAqL1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBhIFlvdVR1YmUgY2hhbm5lbCBieSBuYW1lXG4gKiBAcGFyYW0gY2hhbm5lbE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIGFwaUtleSBZb3VUdWJlIEFQSSBrZXlcbiAqIEByZXR1cm5zIFRoZSBjaGFubmVsIElEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hGb3JDaGFubmVsKGNoYW5uZWxOYW1lOiBzdHJpbmcsIGFwaUtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgdXJsID0gYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3lvdXR1YmUvdjMvc2VhcmNoP3BhcnQ9c25pcHBldCZxPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNoYW5uZWxOYW1lKX0mdHlwZT1jaGFubmVsJmtleT0ke2FwaUtleX1gO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIFxuICBpZiAoIWRhdGEuaXRlbXMgfHwgZGF0YS5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5uZWwgbm90IGZvdW5kJyk7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhLml0ZW1zWzBdLmlkLmNoYW5uZWxJZDtcbn1cblxuLyoqXG4gKiBGZXRjaGVzIHZpZGVvcyBmb3IgYSBZb3VUdWJlIGNoYW5uZWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVmlkZW9zQnlDaGFubmVsKFxuICBjaGFubmVsSWQ6IHN0cmluZywgXG4gIGFwaUtleTogc3RyaW5nLCBcbiAgbWF4UmVzdWx0czogbnVtYmVyID0gNTAsXG4gIHBhZ2VUb2tlbj86IHN0cmluZ1xuKTogUHJvbWlzZTxZb3VUdWJlVmlkZW9SZXNwb25zZT4ge1xuICBjb25zdCB1cmwgPSBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20veW91dHViZS92My9zZWFyY2g/cGFydD1zbmlwcGV0JmNoYW5uZWxJZD0ke2NoYW5uZWxJZH0mbWF4UmVzdWx0cz0ke21heFJlc3VsdHN9Jm9yZGVyPWRhdGUmdHlwZT12aWRlbyZrZXk9JHthcGlLZXl9JHtwYWdlVG9rZW4gPyBgJnBhZ2VUb2tlbj0ke3BhZ2VUb2tlbn1gIDogJyd9YDtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYWxsIHZpZGVvcyBmb3IgYSBZb3VUdWJlIGNoYW5uZWwgd2l0aCBwYWdpbmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFsbFZpZGVvc0J5Q2hhbm5lbChcbiAgY2hhbm5lbElkOiBzdHJpbmcsIFxuICBhcGlLZXk6IHN0cmluZ1xuKTogUHJvbWlzZTxZb3VUdWJlVmlkZW9bXT4ge1xuICBsZXQgYWxsVmlkZW9zOiBZb3VUdWJlVmlkZW9bXSA9IFtdO1xuICBsZXQgbmV4dFBhZ2VUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBcbiAgZG8ge1xuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyB2aWRlb3MgZm9yIGNoYW5uZWwgJHtjaGFubmVsSWR9JHtuZXh0UGFnZVRva2VuID8gYCAocGFnZSB0b2tlbjogJHtuZXh0UGFnZVRva2VufSlgIDogJyd9YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFZpZGVvc0J5Q2hhbm5lbChjaGFubmVsSWQsIGFwaUtleSwgNTAsIG5leHRQYWdlVG9rZW4pO1xuICAgIGFsbFZpZGVvcyA9IFsuLi5hbGxWaWRlb3MsIC4uLihyZXNwb25zZS5pdGVtcyB8fCBbXSldO1xuICAgIG5leHRQYWdlVG9rZW4gPSByZXNwb25zZS5uZXh0UGFnZVRva2VuO1xuICAgIFxuICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGF2b2lkIEFQSSByYXRlIGxpbWl0c1xuICAgIGlmIChuZXh0UGFnZVRva2VuKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgfVxuICB9IHdoaWxlIChuZXh0UGFnZVRva2VuKTtcbiAgXG4gIHJldHVybiBhbGxWaWRlb3M7XG59XG5cbi8qKlxuICogRmV0Y2hlcyBjb21tZW50cyBmb3IgYSBzcGVjaWZpYyB2aWRlb1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21tZW50cyhcbiAgdmlkZW9JZDogc3RyaW5nLCBcbiAgYXBpS2V5OiBzdHJpbmcsIFxuICBwYWdlVG9rZW4/OiBzdHJpbmdcbik6IFByb21pc2U8WW91VHViZUNvbW1lbnRSZXNwb25zZT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS95b3V0dWJlL3YzL2NvbW1lbnRUaHJlYWRzP3BhcnQ9c25pcHBldCxyZXBsaWVzJnZpZGVvSWQ9JHt2aWRlb0lkfSZtYXhSZXN1bHRzPTEwMCZrZXk9JHthcGlLZXl9JHtwYWdlVG9rZW4gPyBgJnBhZ2VUb2tlbj0ke3BhZ2VUb2tlbn1gIDogJyd9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggY29tbWVudHM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb21tZW50czonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIHRoZSBsYXRlc3QgY29tbWVudHMgZnJvbSBhIFlvdVR1YmUgY2hhbm5lbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMYXRlc3RDaGFubmVsQ29tbWVudHMoXG4gIGNoYW5uZWxJZDogc3RyaW5nLFxuICBhcGlLZXk6IHN0cmluZyxcbiAgbWF4VmlkZW9zOiBudW1iZXIgPSAxMCxcbiAgaW5jbHVkZU9sZFZpZGVvczogYm9vbGVhbiA9IGZhbHNlLFxuICBtYXhDb21tZW50czogbnVtYmVyID0gMTAwMCxcbiAgaW5jbHVkZVJlcGxpZXM6IGJvb2xlYW4gPSB0cnVlXG4pOiBQcm9taXNlPFlvdVR1YmVDb21tZW50W10+IHtcbiAgLy8gRmV0Y2ggdmlkZW9zIGZpcnN0XG4gIGxldCB2aWRlb3NSZXNwb25zZSA9IGF3YWl0IGZldGNoVmlkZW9zQnlDaGFubmVsKGNoYW5uZWxJZCwgYXBpS2V5KTtcbiAgbGV0IHByb2Nlc3NlZFZpZGVvcyA9IHZpZGVvc1Jlc3BvbnNlLml0ZW1zIHx8IFtdO1xuICBcbiAgLy8gSWYgd2Ugc2hvdWxkIGluY2x1ZGUgb2xkZXIgdmlkZW9zIGJleW9uZCB0aGUgZmlyc3QgcGFnZVxuICBpZiAoaW5jbHVkZU9sZFZpZGVvcyAmJiB2aWRlb3NSZXNwb25zZS5uZXh0UGFnZVRva2VuKSB7XG4gICAgY29uc3QgYWxsVmlkZW9zID0gYXdhaXQgZmV0Y2hBbGxWaWRlb3NCeUNoYW5uZWwoY2hhbm5lbElkLCBhcGlLZXkpO1xuICAgIHByb2Nlc3NlZFZpZGVvcyA9IGFsbFZpZGVvcztcbiAgICBcbiAgICAvLyBMaW1pdCB0byBtb3N0IHJlY2VudCB2aWRlb3NcbiAgICBpZiAobWF4VmlkZW9zICE9PSAtMSkge1xuICAgICAgcHJvY2Vzc2VkVmlkZW9zID0gcHJvY2Vzc2VkVmlkZW9zLnNsaWNlKDAsIG1heFZpZGVvcyk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBQcm9jZXNzIGVhY2ggdmlkZW8gdG8gZ2V0IGNvbW1lbnRzXG4gIGNvbnN0IGFsbENvbW1lbnRzOiBZb3VUdWJlQ29tbWVudFtdID0gW107XG4gIGxldCBmZXRjaGVkQ29tbWVudENvdW50ID0gMDtcbiAgXG4gIGZvciAoY29uc3QgdmlkZW8gb2YgcHJvY2Vzc2VkVmlkZW9zKSB7XG4gICAgLy8gU2tpcCBpZiB3ZSd2ZSByZWFjaGVkIG1heCBjb21tZW50c1xuICAgIGlmIChtYXhDb21tZW50cyAhPT0gLTEgJiYgZmV0Y2hlZENvbW1lbnRDb3VudCA+PSBtYXhDb21tZW50cykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXg6IEVuc3VyZSB2aWRlb0lkIGlzIHByb3Blcmx5IGFjY2Vzc2VkXG4gICAgICBjb25zdCB2aWRlb0lkID0gdmlkZW8uaWQ/LnZpZGVvSWQ7XG4gICAgICBpZiAoIXZpZGVvSWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIHZpZGVvSWQgZm9yIHZpZGVvOicsIHZpZGVvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGNvbW1lbnRzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzKHZpZGVvSWQsIGFwaUtleSk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3Mgb25seSB0b3AtbGV2ZWwgY29tbWVudHMgdG8gc3RhcnRcbiAgICAgIGNvbnN0IHZpZGVvQ29tbWVudHMgPSBjb21tZW50c1Jlc3BvbnNlLml0ZW1zIHx8IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGNvbW1lbnRUaHJlYWQgb2YgdmlkZW9Db21tZW50cykge1xuICAgICAgICBpZiAoIWNvbW1lbnRUaHJlYWQ/LnNuaXBwZXQ/LnRvcExldmVsQ29tbWVudD8uc25pcHBldCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTWFsZm9ybWVkIGNvbW1lbnQgdGhyZWFkOicsIGNvbW1lbnRUaHJlYWQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzbmlwcGV0ID0gY29tbWVudFRocmVhZC5zbmlwcGV0LnRvcExldmVsQ29tbWVudC5zbmlwcGV0O1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRvIG91ciBsaXN0XG4gICAgICAgIGFsbENvbW1lbnRzLnB1c2goe1xuICAgICAgICAgIGlkOiBjb21tZW50VGhyZWFkLmlkLFxuICAgICAgICAgIHZpZGVvSWQ6IHZpZGVvSWQsXG4gICAgICAgICAgdmlkZW9UaXRsZTogdmlkZW8uc25pcHBldD8udGl0bGUgfHwgJ1Vua25vd24gVmlkZW8nLFxuICAgICAgICAgIGF1dGhvck5hbWU6IHNuaXBwZXQuYXV0aG9yRGlzcGxheU5hbWUsXG4gICAgICAgICAgYXV0aG9yUHJvZmlsZVVybDogc25pcHBldC5hdXRob3JQcm9maWxlSW1hZ2VVcmwsXG4gICAgICAgICAgdGV4dDogc25pcHBldC50ZXh0RGlzcGxheSxcbiAgICAgICAgICBsaWtlQ291bnQ6IHNuaXBwZXQubGlrZUNvdW50LFxuICAgICAgICAgIHB1Ymxpc2hlZEF0OiBzbmlwcGV0LnB1Ymxpc2hlZEF0LFxuICAgICAgICAgIHVwZGF0ZWRBdDogc25pcHBldC51cGRhdGVkQXQgfHwgc25pcHBldC5wdWJsaXNoZWRBdCwgLy8gRmFsbGJhY2sgaWYgdXBkYXRlZEF0IG1pc3NpbmdcbiAgICAgICAgICB0b3RhbFJlcGx5Q291bnQ6IGNvbW1lbnRUaHJlYWQuc25pcHBldC50b3RhbFJlcGx5Q291bnQgfHwgMCxcbiAgICAgICAgICByZXBsaWVzOiBbXSAvLyBJbml0aWFsaXplIGVtcHR5IGFycmF5IGZvciByZXBsaWVzXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZmV0Y2hlZENvbW1lbnRDb3VudCsrO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHJlcGxpZXMgaWYgdGhlcmUgYXJlIGFueSBhbmQgd2Ugd2FudCB0aGVtXG4gICAgICAgIGlmIChpbmNsdWRlUmVwbGllcyAmJiBjb21tZW50VGhyZWFkLnJlcGxpZXM/LmNvbW1lbnRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCByZXBseSBvZiBjb21tZW50VGhyZWFkLnJlcGxpZXMuY29tbWVudHMpIHtcbiAgICAgICAgICAgIGlmICghcmVwbHk/LnNuaXBwZXQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWxmb3JtZWQgcmVwbHk6JywgcmVwbHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWxsQ29tbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiByZXBseS5pZCxcbiAgICAgICAgICAgICAgdmlkZW9JZDogdmlkZW9JZCxcbiAgICAgICAgICAgICAgdmlkZW9UaXRsZTogdmlkZW8uc25pcHBldD8udGl0bGUgfHwgJ1Vua25vd24gVmlkZW8nLFxuICAgICAgICAgICAgICBhdXRob3JOYW1lOiByZXBseS5zbmlwcGV0LmF1dGhvckRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICBhdXRob3JQcm9maWxlVXJsOiByZXBseS5zbmlwcGV0LmF1dGhvclByb2ZpbGVJbWFnZVVybCxcbiAgICAgICAgICAgICAgdGV4dDogcmVwbHkuc25pcHBldC50ZXh0RGlzcGxheSxcbiAgICAgICAgICAgICAgbGlrZUNvdW50OiByZXBseS5zbmlwcGV0Lmxpa2VDb3VudCB8fCAwLFxuICAgICAgICAgICAgICBwdWJsaXNoZWRBdDogcmVwbHkuc25pcHBldC5wdWJsaXNoZWRBdCxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiByZXBseS5zbmlwcGV0LnVwZGF0ZWRBdCB8fCByZXBseS5zbmlwcGV0LnB1Ymxpc2hlZEF0LCAvLyBGYWxsYmFja1xuICAgICAgICAgICAgICB0b3RhbFJlcGx5Q291bnQ6IDAsXG4gICAgICAgICAgICAgIHBhcmVudElkOiBjb21tZW50VGhyZWFkLmlkLFxuICAgICAgICAgICAgICByZXBsaWVzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZldGNoZWRDb21tZW50Q291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIG1heFxuICAgICAgICBpZiAobWF4Q29tbWVudHMgIT09IC0xICYmIGZldGNoZWRDb21tZW50Q291bnQgPj0gbWF4Q29tbWVudHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBKdXN0IGxvZyBhbmQgY29udGludWUgd2l0aCBuZXh0IHZpZGVvXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjb21tZW50cyBmb3IgdmlkZW8gJHt2aWRlby5pZD8udmlkZW9JZH06YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGFsbENvbW1lbnRzO1xufVxuXG4vKipcbiAqIEdldCBZb3VUdWJlIGNvbW1lbnRzIGZvciBhIHZpZGVvXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21tZW50c0ZvclZpZGVvKFxuICB2aWRlb0lkOiBzdHJpbmcsIFxuICBhcGlLZXk6IHN0cmluZywgXG4gIG1heENvbW1lbnRzOiBudW1iZXIgPSAtMSxcbiAgaW5jbHVkZVJlcGxpZXM6IGJvb2xlYW4gPSB0cnVlXG4pIHtcbiAgY29uc29sZS5sb2coYEdldHRpbmcgY29tbWVudHMgZm9yIHZpZGVvICR7dmlkZW9JZH0sIGluY2x1ZGluZyByZXBsaWVzOiAke2luY2x1ZGVSZXBsaWVzfWApO1xuICBcbiAgbGV0IGNvbW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10gPSBbXTsgLy8gVXNpbmcgUmVjb3JkPHN0cmluZywgYW55PiBmb3IgZmxleGliaWxpdHlcbiAgbGV0IG5leHRQYWdlVG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgbGV0IGNvbW1lbnRDb3VudCA9IDA7XG4gIFxuICBkbyB7XG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIGNvbW1lbnRzIHBhZ2UgJHtjb21tZW50Q291bnQgPiAwID8gY29tbWVudENvdW50IC8gMjAgKyAxIDogMX1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHModmlkZW9JZCwgYXBpS2V5LCBuZXh0UGFnZVRva2VuKTtcbiAgICBjb25zdCB2aWRlb0NvbW1lbnRzID0gcmVzcG9uc2UuaXRlbXMgfHwgW107XG4gICAgXG4gICAgLy8gUHJvY2VzcyBlYWNoIHRvcC1sZXZlbCBjb21tZW50XG4gICAgZm9yIChjb25zdCBjb21tZW50IG9mIHZpZGVvQ29tbWVudHMpIHtcbiAgICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICBjb21tZW50Q291bnQrKztcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyByZXBsaWVzIGlmIGF2YWlsYWJsZSBhbmQgcmVxdWVzdGVkXG4gICAgICBpZiAoaW5jbHVkZVJlcGxpZXMgJiYgY29tbWVudC5yZXBsaWVzPy5jb21tZW50cykge1xuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtjb21tZW50LnJlcGxpZXMuY29tbWVudHMubGVuZ3RofSByZXBsaWVzIGZvciBjb21tZW50ICR7Y29tbWVudC5pZH1gKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgcmVwbHkgb2YgY29tbWVudC5yZXBsaWVzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoZSByZXBseSBoYXMgYSBwcm9wZXJseSBmb3JtYXR0ZWQgcGFyZW50X2lkXG4gICAgICAgICAgY29uc3QgcmVwbHlDb21tZW50ID0ge1xuICAgICAgICAgICAgLi4ucmVwbHksXG4gICAgICAgICAgICBzbmlwcGV0OiB7XG4gICAgICAgICAgICAgIC4uLnJlcGx5LnNuaXBwZXQsXG4gICAgICAgICAgICAgIHBhcmVudElkOiBjb21tZW50LmlkLCAgLy8gRXhwbGljaXRseSBzZXQgdGhlIHBhcmVudCBJRCB0byB0aGUgdG9wLWxldmVsIGNvbW1lbnRcbiAgICAgICAgICAgICAgdmlkZW9JZDogdmlkZW9JZCAgICAgICAvLyBFbnN1cmUgdmlkZW9JZCBpcyBpbmNsdWRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29tbWVudHMucHVzaChyZXBseUNvbW1lbnQpO1xuICAgICAgICAgIGNvbW1lbnRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIG5leHRQYWdlVG9rZW4gPSByZXNwb25zZS5uZXh0UGFnZVRva2VuO1xuICAgIFxuICAgIC8vIENvbnRpbnVlIHVudGlsIHdlJ3ZlIHJlYWNoZWQgbWF4IGNvbW1lbnRzIG9yIHJ1biBvdXQgb2YgcGFnZXNcbiAgICBpZiAobWF4Q29tbWVudHMgIT09IC0xICYmIGNvbW1lbnRDb3VudCA+PSBtYXhDb21tZW50cykge1xuICAgICAgY29uc29sZS5sb2coYFJlYWNoZWQgbWF4aW11bSBvZiAke21heENvbW1lbnRzfSBjb21tZW50c2ApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIC8vIFNtYWxsIGRlbGF5IHRvIGF2b2lkIHJhdGUgbGltaXRpbmdcbiAgICBpZiAobmV4dFBhZ2VUb2tlbikge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgIH1cbiAgfSB3aGlsZSAobmV4dFBhZ2VUb2tlbik7XG4gIFxuICBjb25zb2xlLmxvZyhgUmV0cmlldmVkICR7Y29tbWVudHMubGVuZ3RofSBjb21tZW50cyB0b3RhbGApO1xuICByZXR1cm4gY29tbWVudHM7XG59XG5cbi8vIFVwZGF0ZWQgbWFwWW91VHViZUNvbW1lbnRUb0RiQ29tbWVudCBmdW5jdGlvbiB3aXRoIG1vcmUgcm9idXN0IHR5cGUgY2hlY2tpbmdcbmV4cG9ydCBmdW5jdGlvbiBtYXBZb3VUdWJlQ29tbWVudFRvRGJDb21tZW50KGNvbW1lbnQ6IFJlY29yZDxzdHJpbmcsIGFueT4sIGNoYW5uZWxJZDogc3RyaW5nKTogRGJDb21tZW50IHtcbiAgLy8gVmVyeSBleHBsaWNpdGx5IGV4dHJhY3QgcGFyZW50SWQgZnJvbSBhbGwgcG9zc2libGUgbG9jYXRpb25zXG4gIGxldCBwYXJlbnRJZCA9IG51bGw7XG4gIFxuICAvLyBGaXJzdCBjaGVjayBpZiBpdCdzIGluIHNuaXBwZXQucGFyZW50SWRcbiAgaWYgKGNvbW1lbnQuc25pcHBldD8ucGFyZW50SWQpIHtcbiAgICBwYXJlbnRJZCA9IGNvbW1lbnQuc25pcHBldC5wYXJlbnRJZDtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgcGFyZW50SWQgaW4gc25pcHBldC5wYXJlbnRJZDogJHtwYXJlbnRJZH1gKTtcbiAgfSBcbiAgLy8gVGhlbiBjaGVjayByZXBseSBzdHJ1Y3R1cmVcbiAgZWxzZSBpZiAoY29tbWVudC5zbmlwcGV0Py50b3BMZXZlbENvbW1lbnQ/LmlkICYmIGNvbW1lbnQuaWQgIT09IGNvbW1lbnQuc25pcHBldC50b3BMZXZlbENvbW1lbnQuaWQpIHtcbiAgICBwYXJlbnRJZCA9IGNvbW1lbnQuc25pcHBldC50b3BMZXZlbENvbW1lbnQuaWQ7XG4gICAgY29uc29sZS5sb2coYEZvdW5kIHBhcmVudElkIGZyb20gdG9wTGV2ZWxDb21tZW50OiAke3BhcmVudElkfWApO1xuICB9XG4gIFxuICAvLyBJZiB0aGlzIGlzIGEgZGlyZWN0IEFQSSByZXBseSwgaXQgbWlnaHQgYmUgc3RydWN0dXJlZCBkaWZmZXJlbnRseVxuICBpZiAoY29tbWVudC5zbmlwcGV0Py50eXBlID09PSAncmVwbHknICYmIGNvbW1lbnQuc25pcHBldD8ucGFyZW50SWQpIHtcbiAgICBwYXJlbnRJZCA9IGNvbW1lbnQuc25pcHBldC5wYXJlbnRJZDtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgcGFyZW50SWQgZnJvbSByZXBseSB0eXBlOiAke3BhcmVudElkfWApO1xuICB9XG4gIFxuICAvLyBMb2cgbWFwcGluZyBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUubG9nKGBNYXBwaW5nIGNvbW1lbnQgJHtjb21tZW50LmlkfSwgcGFyZW50SWQ6ICR7cGFyZW50SWQgfHwgJ05PTkUgKHRvcC1sZXZlbCknfWApO1xuICBcbiAgLy8gRW5zdXJlIHdlIGhhdmUgcHJvcGVyIGFjY2VzcyB0byBhbGwgcmVxdWlyZWQgcHJvcGVydGllc1xuICBjb25zdCB0b3BMZXZlbFNuaXBwZXQgPSBjb21tZW50LnNuaXBwZXQ/LnRvcExldmVsQ29tbWVudD8uc25pcHBldDtcbiAgY29uc3QgZGlyZWN0U25pcHBldCA9IGNvbW1lbnQuc25pcHBldDtcbiAgXG4gIHJldHVybiB7XG4gICAgY29tbWVudF9pZDogY29tbWVudC5pZCxcbiAgICB2aWRlb19pZDogZGlyZWN0U25pcHBldD8udmlkZW9JZCxcbiAgICBhdXRob3JfbmFtZTogdG9wTGV2ZWxTbmlwcGV0Py5hdXRob3JEaXNwbGF5TmFtZSB8fCBkaXJlY3RTbmlwcGV0Py5hdXRob3JEaXNwbGF5TmFtZSxcbiAgICBhdXRob3JfcHJvZmlsZV91cmw6IHRvcExldmVsU25pcHBldD8uYXV0aG9yUHJvZmlsZUltYWdlVXJsIHx8IGRpcmVjdFNuaXBwZXQ/LmF1dGhvclByb2ZpbGVJbWFnZVVybCxcbiAgICB0ZXh0OiB0b3BMZXZlbFNuaXBwZXQ/LnRleHREaXNwbGF5IHx8IGRpcmVjdFNuaXBwZXQ/LnRleHREaXNwbGF5LFxuICAgIGxpa2VfY291bnQ6IHRvcExldmVsU25pcHBldD8ubGlrZUNvdW50IHx8IGRpcmVjdFNuaXBwZXQ/Lmxpa2VDb3VudCB8fCAwLFxuICAgIHB1Ymxpc2hlZF9hdDogdG9wTGV2ZWxTbmlwcGV0Py5wdWJsaXNoZWRBdCB8fCBkaXJlY3RTbmlwcGV0Py5wdWJsaXNoZWRBdCxcbiAgICBjaGFubmVsX2lkOiBjaGFubmVsSWQsXG4gICAgaXNfb3duZXJfY29tbWVudDogZmFsc2UsXG4gICAgcGFyZW50X2lkOiBwYXJlbnRJZCxcbiAgICB2aWRlb190aXRsZTogZGlyZWN0U25pcHBldD8udmlkZW9UaXRsZSB8fCAnJyxcbiAgfTtcbn1cblxuLy8gRW5oYW5jZWQgbWFwcGluZyBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgYWxsIHBvc3NpYmxlIHByb3BlcnRpZXNcbmV4cG9ydCBmdW5jdGlvbiBtYXBEYkNvbW1lbnRUb0NvbW1lbnREYXRhKGRiQ29tbWVudDogUmVjb3JkPHN0cmluZywgYW55Pik6IENvbW1lbnREYXRhIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogZGJDb21tZW50LmNvbW1lbnRfaWQsXG4gICAgYXV0aG9yRGlzcGxheU5hbWU6IGRiQ29tbWVudC5hdXRob3JfbmFtZSB8fCAnVW5rbm93biBVc2VyJyxcbiAgICBhdXRob3JQcm9maWxlSW1hZ2VVcmw6IGRiQ29tbWVudC5hdXRob3JfcHJvZmlsZV91cmwgfHwgJ2h0dHBzOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIvP2Q9bXAnLFxuICAgIHRleHREaXNwbGF5OiBkZWNvZGVBbGxIdG1sRW50aXRpZXMoZGJDb21tZW50LnRleHQgfHwgJycpLFxuICAgIGxpa2VDb3VudDogZGJDb21tZW50Lmxpa2VfY291bnQgfHwgMCxcbiAgICBwdWJsaXNoZWRBdDogZGJDb21tZW50LnB1Ymxpc2hlZF9hdCxcbiAgICB1cGRhdGVkQXQ6IGRiQ29tbWVudC51cGRhdGVkX2F0IHx8IGRiQ29tbWVudC5wdWJsaXNoZWRfYXQsXG4gICAgdmlkZW9JZDogZGJDb21tZW50LnZpZGVvX2lkLFxuICAgIHZpZGVvVGl0bGU6IGRiQ29tbWVudC52aWRlb190aXRsZSB8fCAnJyxcbiAgICByZXBseUNvdW50OiBkYkNvbW1lbnQucmVwbHlfY291bnQgfHwgMCxcbiAgICBpc0hlYXJ0ZWRCeUNyZWF0b3I6IGZhbHNlLFxuICAgIGlzUGlubmVkOiBmYWxzZSxcbiAgICBwYXJlbnRJZDogZGJDb21tZW50LnBhcmVudF9pZCxcbiAgICByZXBsaWVzOiBbXSAvLyBXaWxsIGJlIHBvcHVsYXRlZCBzZXBhcmF0ZWx5IGlmIG5lZWRlZFxuICB9O1xufVxuXG4vLyBEZWJ1ZyBmdW5jdGlvbiB0byBpbnNwZWN0IHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzIGluIHRoZSBkYXRhYmFzZVxuZnVuY3Rpb24gbG9nQWxsUGFyZW50Q2hpbGRSZWxhdGlvbnNoaXBzKCkge1xuICByZXR1cm4gc3VwYWJhc2VcbiAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgIC5zZWxlY3QoJ2NvbW1lbnRfaWQsIHBhcmVudF9pZCcpXG4gICAgLm5vdCgncGFyZW50X2lkJywgJ2lzJywgbnVsbClcbiAgICAubGltaXQoMjApXG4gICAgLnRoZW4oKHsgZGF0YSwgZXJyb3IgfSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gUEFSRU5ULUNISUxEIERFQlVHIC0gU2FtcGxlIGNvbW1lbnRzIHdpdGggcGFyZW50czonLCBkYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBpZiBhbnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59XG5cbi8vIE1vZGlmaWVkIGdldENvbW1lbnRSZXBsaWVzIGZ1bmN0aW9uIHRvIGZpeCByZXBseSBsb29rdXBcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21tZW50UmVwbGllcyhjb21tZW50SWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIGdldENvbW1lbnRSZXBsaWVzIC0gTG9va2luZyBmb3IgcmVwbGllcyB0byBjb21tZW50SWQ6JywgY29tbWVudElkKTtcbiAgICBcbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgYW55IGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSBoYXZlIHBhcmVudF9pZCBtYXRjaGluZyBvdXIgY29tbWVudElkXG4gICAgY29uc3QgeyBkYXRhOiByZXBseUNoZWNrLCBlcnJvcjogcmVwbHlDaGVja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgIC5zZWxlY3QoJ2NvdW50KCopJylcbiAgICAgIC5lcSgncGFyZW50X2lkJywgY29tbWVudElkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogZ2V0Q29tbWVudFJlcGxpZXMgLSBSZXBseSBjaGVjayByZXN1bHQ6JywgcmVwbHlDaGVjayk7XG4gICAgXG4gICAgaWYgKHJlcGx5Q2hlY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFJlcGx5IGNoZWNrIGVycm9yOicsIHJlcGx5Q2hlY2tFcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHRoZSBhY3R1YWwgY29tbWVudCB3ZSdyZSBsb29raW5nIGZvciByZXBsaWVzIHRvXG4gICAgY29uc3QgeyBkYXRhOiBwYXJlbnRDb21tZW50LCBlcnJvcjogcGFyZW50RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NvbW1lbnRfaWQnLCBjb21tZW50SWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICBpZiAocGFyZW50Q29tbWVudCkge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBGb3VuZCBwYXJlbnQgY29tbWVudDonLCB7XG4gICAgICAgIGlkOiBwYXJlbnRDb21tZW50LmlkLFxuICAgICAgICBjb21tZW50X2lkOiBwYXJlbnRDb21tZW50LmNvbW1lbnRfaWQsXG4gICAgICAgIHZpZGVvX2lkOiBwYXJlbnRDb21tZW50LnZpZGVvX2lkLFxuICAgICAgICB0ZXh0OiBwYXJlbnRDb21tZW50LnRleHQ/LnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJyB8fCAnJ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gUGFyZW50IGNvbW1lbnQgbm90IGZvdW5kIGZvciBJRDonLCBjb21tZW50SWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZWFyY2ggZm9yIHJlcGxpZXMgZGlyZWN0bHkgXG4gICAgY29uc3QgeyBkYXRhOiByZXBsaWVzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb21tZW50cycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgncGFyZW50X2lkJywgY29tbWVudElkKSAvLyBUaGlzIGFzc3VtZXMgcGFyZW50X2lkIHJlZmVyZW5jZXMgY29tbWVudF9pZCBcbiAgICAgIC5vcmRlcigncHVibGlzaGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgcmVwbGllczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5OKIEZvdW5kICR7cmVwbGllcz8ubGVuZ3RoIHx8IDB9IHJlcGxpZXMgZm9yIGNvbW1lbnQ6YCwgY29tbWVudElkKTtcbiAgICBcbiAgICBpZiAocmVwbGllcyAmJiByZXBsaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFNhbXBsZSB0aGUgZmlyc3QgcmVwbHlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEZpcnN0IHJlcGx5IHNhbXBsZTonLCB7XG4gICAgICAgIGlkOiByZXBsaWVzWzBdLmlkLFxuICAgICAgICBjb21tZW50X2lkOiByZXBsaWVzWzBdLmNvbW1lbnRfaWQsXG4gICAgICAgIHBhcmVudF9pZDogcmVwbGllc1swXS5wYXJlbnRfaWQsXG4gICAgICAgIHZpZGVvX2lkOiByZXBsaWVzWzBdLnZpZGVvX2lkLFxuICAgICAgICB0ZXh0OiByZXBsaWVzWzBdLnRleHQ/LnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJyB8fCAnJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1hcCB0byB0aGUgZXhwZWN0ZWQgZm9ybWF0XG4gICAgY29uc3QgcmVwbHlEYXRhID0gcmVwbGllcz8ubWFwKHJlcGx5ID0+IG1hcERiQ29tbWVudFRvQ29tbWVudERhdGEocmVwbHkpKSB8fCBbXTtcbiAgICBcbiAgICByZXR1cm4gcmVwbHlEYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRDb21tZW50UmVwbGllczonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vIEdldCB2aWRlb3MgZm9yIGEgY2hhbm5lbFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENoYW5uZWxWaWRlb3MoY2hhbm5lbElkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IEdldCB0aGUgaW50ZXJuYWwgVVVJRCBmb3IgdGhpcyBZb3VUdWJlIGNoYW5uZWwgSURcbiAgICBjb25zdCB7IGRhdGE6IGNoYW5uZWwgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2hhbm5lbHMnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmVxKCdjaGFubmVsX2lkJywgY2hhbm5lbElkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgIFxuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgY29uc29sZS5sb2coJ0NoYW5uZWwgbm90IGZvdW5kIHdpdGggSUQ6JywgY2hhbm5lbElkKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0ZvdW5kIGNoYW5uZWwsIGludGVybmFsIElEOicsIGNoYW5uZWwuaWQpO1xuICAgIFxuICAgIC8vIFN0ZXAgMjogVXNlIHRoZSBpbnRlcm5hbCBVVUlEIHRvIHF1ZXJ5IHZpZGVvc1xuICAgIGNvbnN0IHsgZGF0YTogdmlkZW9zLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2aWRlb3MnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NoYW5uZWxfaWQnLCBjaGFubmVsLmlkKTsgIC8vIFVzaW5nIGludGVybmFsIFVVSUQgaW5zdGVhZCBvZiBZb3VUdWJlIGNoYW5uZWwgSURcbiAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZpZGVvczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF2aWRlb3MgfHwgdmlkZW9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYXAgREIgdmlkZW9zIHRvIFZpZGVvRGF0YSBmb3JtYXRcbiAgICBjb25zdCB2aWRlb0RhdGE6IFZpZGVvRGF0YVtdID0gdmlkZW9zLm1hcCh2aWRlbyA9PiAoe1xuICAgICAgaWQ6IHZpZGVvLnZpZGVvX2lkLFxuICAgICAgdGl0bGU6IHZpZGVvLnRpdGxlIHx8ICdVbnRpdGxlZCBWaWRlbycsXG4gICAgICBkZXNjcmlwdGlvbjogdmlkZW8uZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICBwdWJsaXNoZWRBdDogdmlkZW8ucHVibGlzaGVkX2F0LFxuICAgICAgdGh1bWJuYWlsVXJsOiB2aWRlby50aHVtYm5haWxfdXJsIHx8ICcnLFxuICAgICAgY2hhbm5lbElkOiB2aWRlby5jaGFubmVsX2lkXG4gICAgfSkpO1xuICAgIFxuICAgIHJldHVybiB2aWRlb0RhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q2hhbm5lbFZpZGVvczonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vIEFkZCB0aGlzIGZ1bmN0aW9uIHRvIGluc3BlY3QgYSBjb21tZW50IHJlY29yZFxuZnVuY3Rpb24gaW5zcGVjdENvbW1lbnQoY29tbWVudDogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICBjb25zb2xlLmxvZygnQ29tbWVudCBzdHJ1Y3R1cmU6Jywge1xuICAgIGlkOiBjb21tZW50LmlkLFxuICAgIGNvbW1lbnRfaWQ6IGNvbW1lbnQuY29tbWVudF9pZCxcbiAgICB2aWRlb19pZDogY29tbWVudC52aWRlb19pZCxcbiAgICBwYXJlbnRfaWQ6IGNvbW1lbnQucGFyZW50X2lkLFxuICAgIGNoYW5uZWxfaWQ6IGNvbW1lbnQuY2hhbm5lbF9pZCxcbiAgICAvLyBBZGQgb3RoZXIgZmllbGRzIHlvdSBleHBlY3RcbiAgfSk7XG59XG5cbi8vIFVwZGF0ZSB0aGUgZ2V0Q29tbWVudFRocmVhZHMgZnVuY3Rpb24gd2l0aCBhZGRpdGlvbmFsIGRlYnVnZ2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbW1lbnRUaHJlYWRzKFxuICBjaGFubmVsSWQ6IHN0cmluZywgXG4gIHZpZGVvSWQ/OiBzdHJpbmcsIFxuICBwYWdlOiBudW1iZXIgPSAxLCBcbiAgcGVyUGFnZTogbnVtYmVyID0gMjBcbikge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5SOIGdldENvbW1lbnRUaHJlYWRzIC0gSW5wdXRzOicsIHsgY2hhbm5lbElkLCB2aWRlb0lkLCBwYWdlLCBwZXJQYWdlIH0pO1xuXG4gICAgLy8gU3RlcCAxOiBHZXQgdGhlIGludGVybmFsIFVVSUQgZm9yIHRoaXMgWW91VHViZSBjaGFubmVsIElEXG4gICAgY29uc3QgeyBkYXRhOiBjaGFubmVsLCBlcnJvcjogY2hhbm5lbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NoYW5uZWxzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjaGFubmVsX2lkJywgY2hhbm5lbElkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgIFxuICAgIGlmIChjaGFubmVsRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb21tZW50VGhyZWFkcyAtIEVycm9yIGZpbmRpbmcgY2hhbm5lbDonLCBjaGFubmVsRXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gZ2V0Q29tbWVudFRocmVhZHMgLSBDaGFubmVsIG5vdCBmb3VuZCB3aXRoIElEOicsIGNoYW5uZWxJZCk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfinIUgZ2V0Q29tbWVudFRocmVhZHMgLSBGb3VuZCBjaGFubmVsOicsIHsgXG4gICAgICBpbnRlcm5hbF9pZDogY2hhbm5lbC5pZCwgXG4gICAgICBjaGFubmVsX2lkOiBjaGFubmVsLmNoYW5uZWxfaWQsXG4gICAgICB0aXRsZTogY2hhbm5lbC50aXRsZVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFN0ZXAgMjogVXNlIHRoZSBpbnRlcm5hbCBVVUlEIHRvIHF1ZXJ5IGNvbW1lbnRzXG4gICAgY29uc3Qgc3RhcnRJZHggPSAocGFnZSAtIDEpICogcGVyUGFnZTtcbiAgICBjb25zdCBlbmRJZHggPSBwYWdlICogcGVyUGFnZSAtIDE7XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCflKIgZ2V0Q29tbWVudFRocmVhZHMgLSBSYW5nZTogJHtzdGFydElkeH0gdG8gJHtlbmRJZHh9YCk7XG4gICAgXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb21tZW50cycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2hhbm5lbF9pZCcsIGNoYW5uZWwuaWQpXG4gICAgICAuaXMoJ3BhcmVudF9pZCcsIG51bGwpIC8vIE9ubHkgZ2V0IHRvcC1sZXZlbCBjb21tZW50c1xuICAgICAgLm9yZGVyKCdwdWJsaXNoZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIC5yYW5nZShzdGFydElkeCwgZW5kSWR4KTtcbiAgICBcbiAgICBpZiAodmlkZW9JZCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgndmlkZW9faWQnLCB2aWRlb0lkKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBkYXRhOiBjb21tZW50cywgZXJyb3I6IGNvbW1lbnRzRXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgIFxuICAgIGlmIChjb21tZW50c0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q29tbWVudFRocmVhZHMgLSBFcnJvciBmZXRjaGluZyBjb21tZW50czonLCBjb21tZW50c0Vycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk4ogZ2V0Q29tbWVudFRocmVhZHMgLSBGb3VuZCAke2NvbW1lbnRzPy5sZW5ndGggfHwgMH0gY29tbWVudHNgKTtcbiAgICBcbiAgICBpZiAoIWNvbW1lbnRzIHx8IGNvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICAvLyBTYW1wbGUgdGhlIGZpcnN0IGNvbW1lbnQgdG8gZGVidWdcbiAgICBpZiAoY29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gZ2V0Q29tbWVudFRocmVhZHMgLSBGaXJzdCBjb21tZW50OicsIHtcbiAgICAgICAgaWQ6IGNvbW1lbnRzWzBdLmlkLFxuICAgICAgICBjb21tZW50X2lkOiBjb21tZW50c1swXS5jb21tZW50X2lkLFxuICAgICAgICBwYXJlbnRfaWQ6IGNvbW1lbnRzWzBdLnBhcmVudF9pZCxcbiAgICAgICAgY2hhbm5lbF9pZDogY29tbWVudHNbMF0uY2hhbm5lbF9pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciBlYWNoIGNvbW1lbnQsIGNvdW50IHJlcGxpZXMgYW5kIG1hcCB0byBDb21tZW50RGF0YSBmb3JtYXRcbiAgICBjb25zdCBjb21tZW50RGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgY29tbWVudHMubWFwKGFzeW5jIChjb21tZW50KSA9PiB7XG4gICAgICAgIC8vIENvdW50IHJlcGxpZXMgZm9yIHRoaXMgY29tbWVudCBcbiAgICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmVxKCdwYXJlbnRfaWQnLCBjb21tZW50LmNvbW1lbnRfaWQpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVwbHlDb3VudCA9IGNvdW50IHx8IDA7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXAgREIgY29tbWVudCB0byBDb21tZW50RGF0YSBmb3JtYXQgd2l0aCByZXBseSBjb3VudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm1hcERiQ29tbWVudFRvQ29tbWVudERhdGEoY29tbWVudCksXG4gICAgICAgICAgcmVwbHlDb3VudFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICAgIFxuICAgIHJldHVybiBjb21tZW50RGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q29tbWVudFRocmVhZHMgLSBVbmhhbmRsZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29tbWVudFJlcGx5Q291bnRzKCkge1xuICBjb25zb2xlLmxvZygnVXBkYXRpbmcgcmVwbHkgY291bnRzIGZvciBhbGwgY29tbWVudHMuLi4nKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gRm9yIGVhY2ggY29tbWVudCB3aXRoIHJlcGxpZXMsIGNvdW50IHRoZW0gYW5kIHVwZGF0ZSB0aGUgcmVwbHlfY291bnRcbiAgICBjb25zdCB7IGRhdGE6IGNvbW1lbnRzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgIC5zZWxlY3QoJ2NvbW1lbnRfaWQnKVxuICAgICAgLmlzKCdwYXJlbnRfaWQnLCBudWxsKTtcbiAgICBcbiAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgXG4gICAgZm9yIChjb25zdCBjb21tZW50IG9mIGNvbW1lbnRzKSB7XG4gICAgICAvLyBDb3VudCB0aGUgcmVwbGllcyBmb3IgdGhpcyBjb21tZW50XG4gICAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAuZXEoJ3BhcmVudF9pZCcsIGNvbW1lbnQuY29tbWVudF9pZCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcmVwbHlfY291bnRcbiAgICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgICAgICAudXBkYXRlKHsgcmVwbHlfY291bnQ6IGNvdW50IH0pXG4gICAgICAgICAgLmVxKCdjb21tZW50X2lkJywgY29tbWVudC5jb21tZW50X2lkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1JlcGx5IGNvdW50cyB1cGRhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHJlcGx5IGNvdW50czonLCBlcnJvcik7XG4gIH1cbn0gIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwiZGVjb2RlQWxsSHRtbEVudGl0aWVzIiwic2VhcmNoRm9yQ2hhbm5lbCIsImNoYW5uZWxOYW1lIiwiYXBpS2V5IiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwiaXRlbXMiLCJsZW5ndGgiLCJFcnJvciIsImlkIiwiY2hhbm5lbElkIiwiZmV0Y2hWaWRlb3NCeUNoYW5uZWwiLCJtYXhSZXN1bHRzIiwicGFnZVRva2VuIiwiZmV0Y2hBbGxWaWRlb3NCeUNoYW5uZWwiLCJhbGxWaWRlb3MiLCJuZXh0UGFnZVRva2VuIiwiY29uc29sZSIsImxvZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImZldGNoQ29tbWVudHMiLCJ2aWRlb0lkIiwib2siLCJzdGF0dXNUZXh0IiwiZXJyb3IiLCJmZXRjaExhdGVzdENoYW5uZWxDb21tZW50cyIsIm1heFZpZGVvcyIsImluY2x1ZGVPbGRWaWRlb3MiLCJtYXhDb21tZW50cyIsImluY2x1ZGVSZXBsaWVzIiwidmlkZW9zUmVzcG9uc2UiLCJwcm9jZXNzZWRWaWRlb3MiLCJzbGljZSIsImFsbENvbW1lbnRzIiwiZmV0Y2hlZENvbW1lbnRDb3VudCIsInZpZGVvIiwid2FybiIsImNvbW1lbnRzUmVzcG9uc2UiLCJ2aWRlb0NvbW1lbnRzIiwiY29tbWVudFRocmVhZCIsInNuaXBwZXQiLCJ0b3BMZXZlbENvbW1lbnQiLCJwdXNoIiwidmlkZW9UaXRsZSIsInRpdGxlIiwiYXV0aG9yTmFtZSIsImF1dGhvckRpc3BsYXlOYW1lIiwiYXV0aG9yUHJvZmlsZVVybCIsImF1dGhvclByb2ZpbGVJbWFnZVVybCIsInRleHQiLCJ0ZXh0RGlzcGxheSIsImxpa2VDb3VudCIsInB1Ymxpc2hlZEF0IiwidXBkYXRlZEF0IiwidG90YWxSZXBseUNvdW50IiwicmVwbGllcyIsImNvbW1lbnRzIiwicmVwbHkiLCJwYXJlbnRJZCIsImdldENvbW1lbnRzRm9yVmlkZW8iLCJjb21tZW50Q291bnQiLCJjb21tZW50IiwicmVwbHlDb21tZW50IiwibWFwWW91VHViZUNvbW1lbnRUb0RiQ29tbWVudCIsInR5cGUiLCJ0b3BMZXZlbFNuaXBwZXQiLCJkaXJlY3RTbmlwcGV0IiwiY29tbWVudF9pZCIsInZpZGVvX2lkIiwiYXV0aG9yX25hbWUiLCJhdXRob3JfcHJvZmlsZV91cmwiLCJsaWtlX2NvdW50IiwicHVibGlzaGVkX2F0IiwiY2hhbm5lbF9pZCIsImlzX293bmVyX2NvbW1lbnQiLCJwYXJlbnRfaWQiLCJ2aWRlb190aXRsZSIsIm1hcERiQ29tbWVudFRvQ29tbWVudERhdGEiLCJkYkNvbW1lbnQiLCJ1cGRhdGVkX2F0IiwicmVwbHlDb3VudCIsInJlcGx5X2NvdW50IiwiaXNIZWFydGVkQnlDcmVhdG9yIiwiaXNQaW5uZWQiLCJsb2dBbGxQYXJlbnRDaGlsZFJlbGF0aW9uc2hpcHMiLCJmcm9tIiwic2VsZWN0Iiwibm90IiwibGltaXQiLCJ0aGVuIiwiZ2V0Q29tbWVudFJlcGxpZXMiLCJjb21tZW50SWQiLCJyZXBseUNoZWNrIiwicmVwbHlDaGVja0Vycm9yIiwiZXEiLCJzaW5nbGUiLCJwYXJlbnRDb21tZW50IiwicGFyZW50RXJyb3IiLCJzdWJzdHJpbmciLCJvcmRlciIsImFzY2VuZGluZyIsInJlcGx5RGF0YSIsIm1hcCIsImdldENoYW5uZWxWaWRlb3MiLCJjaGFubmVsIiwidmlkZW9zIiwidmlkZW9EYXRhIiwiZGVzY3JpcHRpb24iLCJ0aHVtYm5haWxVcmwiLCJ0aHVtYm5haWxfdXJsIiwiaW5zcGVjdENvbW1lbnQiLCJnZXRDb21tZW50VGhyZWFkcyIsInBhZ2UiLCJwZXJQYWdlIiwiY2hhbm5lbEVycm9yIiwiaW50ZXJuYWxfaWQiLCJzdGFydElkeCIsImVuZElkeCIsInF1ZXJ5IiwiaXMiLCJyYW5nZSIsImNvbW1lbnRzRXJyb3IiLCJjb21tZW50RGF0YSIsImFsbCIsImNvdW50IiwiaGVhZCIsInVwZGF0ZUNvbW1lbnRSZXBseUNvdW50cyIsInVuZGVmaW5lZCIsInVwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/youtube.ts\n"));

/***/ })

});