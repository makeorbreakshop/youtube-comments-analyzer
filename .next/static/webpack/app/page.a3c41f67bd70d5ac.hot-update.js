"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/youtube.ts":
/*!************************!*\
  !*** ./lib/youtube.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchAllVideosByChannel: function() { return /* binding */ fetchAllVideosByChannel; },\n/* harmony export */   fetchComments: function() { return /* binding */ fetchComments; },\n/* harmony export */   fetchLatestChannelComments: function() { return /* binding */ fetchLatestChannelComments; },\n/* harmony export */   fetchVideosByChannel: function() { return /* binding */ fetchVideosByChannel; },\n/* harmony export */   getChannelVideos: function() { return /* binding */ getChannelVideos; },\n/* harmony export */   getCommentReplies: function() { return /* binding */ getCommentReplies; },\n/* harmony export */   getCommentThreads: function() { return /* binding */ getCommentThreads; },\n/* harmony export */   getCommentsForVideo: function() { return /* binding */ getCommentsForVideo; },\n/* harmony export */   mapDbCommentToCommentData: function() { return /* binding */ mapDbCommentToCommentData; },\n/* harmony export */   mapYouTubeCommentToDbComment: function() { return /* binding */ mapYouTubeCommentToDbComment; },\n/* harmony export */   searchForChannel: function() { return /* binding */ searchForChannel; },\n/* harmony export */   updateCommentReplyCounts: function() { return /* binding */ updateCommentReplyCounts; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./lib/utils.ts\");\n\n\n/**\n * YouTube API integration for fetching channel data and comments\n * Based on the YouTube Data API v3 documentation: \n * https://developers.google.com/youtube/v3/docs\n */ /**\n * Searches for a YouTube channel by name\n * @param channelName The name of the channel to search for\n * @param apiKey YouTube API key\n * @returns The channel ID\n */ async function searchForChannel(channelName, apiKey) {\n    const url = \"https://www.googleapis.com/youtube/v3/search?part=snippet&q=\".concat(encodeURIComponent(channelName), \"&type=channel&key=\").concat(apiKey);\n    const response = await fetch(url);\n    const data = await response.json();\n    if (!data.items || data.items.length === 0) {\n        throw new Error(\"Channel not found\");\n    }\n    return data.items[0].id.channelId;\n}\n/**\n * Fetches videos for a YouTube channel\n */ async function fetchVideosByChannel(channelId, apiKey) {\n    let maxResults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50, pageToken = arguments.length > 3 ? arguments[3] : void 0;\n    const url = \"https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=\".concat(channelId, \"&maxResults=\").concat(maxResults, \"&order=date&type=video&key=\").concat(apiKey).concat(pageToken ? \"&pageToken=\".concat(pageToken) : \"\");\n    const response = await fetch(url);\n    return await response.json();\n}\n/**\n * Fetches all videos for a YouTube channel with pagination\n */ async function fetchAllVideosByChannel(channelId, apiKey) {\n    let allVideos = [];\n    let nextPageToken;\n    do {\n        console.log(\"Fetching videos for channel \".concat(channelId).concat(nextPageToken ? \" (page token: \".concat(nextPageToken, \")\") : \"\"));\n        const response = await fetchVideosByChannel(channelId, apiKey, 50, nextPageToken);\n        allVideos = [\n            ...allVideos,\n            ...response.items || []\n        ];\n        nextPageToken = response.nextPageToken;\n        // Add a small delay to avoid API rate limits\n        if (nextPageToken) {\n            await new Promise((resolve)=>setTimeout(resolve, 100));\n        }\n    }while (nextPageToken);\n    return allVideos;\n}\n/**\n * Fetches comments for a specific video\n */ async function fetchComments(videoId, apiKey, pageToken) {\n    try {\n        const url = \"https://www.googleapis.com/youtube/v3/commentThreads?part=snippet,replies&videoId=\".concat(videoId, \"&maxResults=100&key=\").concat(apiKey).concat(pageToken ? \"&pageToken=\".concat(pageToken) : \"\");\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch comments: \".concat(response.statusText));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Error fetching comments:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches the latest comments from a YouTube channel\n */ async function fetchLatestChannelComments(channelId, apiKey) {\n    let maxVideos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, includeOldVideos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, maxComments = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1000, includeReplies = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;\n    // Fetch videos first\n    console.log(\"Fetching videos for channel \".concat(channelId));\n    let videosResponse = await fetchVideosByChannel(channelId, apiKey);\n    let processedVideos = videosResponse.items || [];\n    // If we should include older videos beyond the first page\n    if (includeOldVideos && videosResponse.nextPageToken) {\n        console.log(\"Including older videos\");\n        const allVideos = await fetchAllVideosByChannel(channelId, apiKey);\n        processedVideos = allVideos;\n        // Limit to most recent videos\n        if (maxVideos !== -1) {\n            processedVideos = processedVideos.slice(0, maxVideos);\n        }\n    }\n    // Fetch comments for each video\n    let allComments = [];\n    let totalCommentsAdded = 0;\n    for (const video of processedVideos){\n        var _video_id, _video_id_resourceId, _video_id1;\n        const videoId = typeof video.id === \"string\" ? video.id : ((_video_id = video.id) === null || _video_id === void 0 ? void 0 : _video_id.videoId) || ((_video_id1 = video.id) === null || _video_id1 === void 0 ? void 0 : (_video_id_resourceId = _video_id1.resourceId) === null || _video_id_resourceId === void 0 ? void 0 : _video_id_resourceId.videoId);\n        const videoTitle = video.snippet.title;\n        try {\n            let comments = [];\n            let commentNextPageToken;\n            // Get comments until we reach maxComments or run out of pages\n            let commentPages = 0;\n            do {\n                console.log(\"Fetching comments for video: \".concat(videoTitle, \" (page \").concat(commentPages + 1, \")\"));\n                const commentResponse = await fetchComments(videoId, apiKey, commentNextPageToken);\n                const videoComments = commentResponse.items || [];\n                // Add each comment\n                for (const comment of videoComments){\n                    // Add video title for context\n                    const enrichedComment = {\n                        ...comment,\n                        snippet: {\n                            ...comment.snippet,\n                            videoTitle\n                        }\n                    };\n                    comments.push(enrichedComment);\n                    // Add replies if requested and available\n                    if (includeReplies && comment.replies && comment.replies.comments) {\n                        for (const reply of comment.replies.comments){\n                            // Format reply as a YouTubeComment\n                            const replyComment = {\n                                id: reply.id,\n                                snippet: {\n                                    videoId,\n                                    topLevelComment: {\n                                        snippet: reply.snippet\n                                    },\n                                    videoTitle,\n                                    parentId: comment.id\n                                }\n                            };\n                            comments.push(replyComment);\n                        }\n                    }\n                }\n                commentNextPageToken = commentResponse.nextPageToken;\n                commentPages++;\n                // Continue fetching more pages if available and within limits\n                if (commentNextPageToken && (maxComments === -1 || totalCommentsAdded + comments.length < maxComments)) {\n                    // Add a small delay to avoid API rate limits\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                    console.log(\"More comments available for \".concat(videoTitle, \", fetching page \").concat(commentPages + 1, \"...\"));\n                } else {\n                    break;\n                }\n            }while (commentNextPageToken);\n            allComments = [\n                ...allComments,\n                ...comments\n            ];\n            totalCommentsAdded += comments.length;\n            // Stop if we've reached the maximum number of comments\n            if (maxComments !== -1 && totalCommentsAdded >= maxComments) {\n                console.log(\"Reached maximum of \".concat(maxComments, \" comments\"));\n                break;\n            }\n        } catch (error) {\n            console.error(\"Error fetching comments for video \".concat(videoId, \":\"), error);\n        // Continue with other videos\n        }\n    }\n    return allComments;\n}\n/**\n * Get YouTube comments for a video\n */ async function getCommentsForVideo(videoId, apiKey) {\n    let maxComments = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, includeReplies = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n    console.log(\"Getting comments for video \".concat(videoId, \", including replies: \").concat(includeReplies));\n    let comments = [];\n    let nextPageToken;\n    let commentCount = 0;\n    do {\n        console.log(\"Fetching comments page \".concat(commentCount > 0 ? commentCount / 20 + 1 : 1));\n        const response = await fetchComments(videoId, apiKey, nextPageToken);\n        const videoComments = response.items || [];\n        // Process each top-level comment\n        for (const comment of videoComments){\n            comments.push(comment);\n            commentCount++;\n            // Process replies if available and requested\n            if (includeReplies && comment.replies && comment.replies.comments) {\n                console.log(\"Found \".concat(comment.replies.comments.length, \" replies for comment \").concat(comment.id));\n                for (const reply of comment.replies.comments){\n                    // Ensure the reply has a properly formatted parent_id\n                    const replyComment = {\n                        ...reply,\n                        snippet: {\n                            ...reply.snippet,\n                            parentId: comment.id,\n                            videoId: videoId // Ensure videoId is included\n                        }\n                    };\n                    comments.push(replyComment);\n                    commentCount++;\n                }\n            }\n        }\n        nextPageToken = response.nextPageToken;\n        // Continue until we've reached max comments or run out of pages\n        if (maxComments !== -1 && commentCount >= maxComments) {\n            console.log(\"Reached maximum of \".concat(maxComments, \" comments\"));\n            break;\n        }\n        // Small delay to avoid rate limiting\n        if (nextPageToken) {\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n        }\n    }while (nextPageToken);\n    console.log(\"Retrieved \".concat(comments.length, \" comments total\"));\n    return comments;\n}\n// Updated mapYouTubeCommentToDbComment function\nfunction mapYouTubeCommentToDbComment(comment, channelId) {\n    var _comment_snippet, _comment_snippet_topLevelComment, _comment_snippet1, _comment_snippet2, _comment_snippet3, _comment_snippet_topLevelComment_snippet, _comment_snippet_topLevelComment1, _comment_snippet_topLevelComment_snippet1, _comment_snippet_topLevelComment2, _comment_snippet_topLevelComment_snippet2, _comment_snippet_topLevelComment3, _comment_snippet_topLevelComment_snippet3, _comment_snippet_topLevelComment4, _comment_snippet_topLevelComment_snippet4, _comment_snippet_topLevelComment5;\n    // Very explicitly extract parentId from all possible locations\n    let parentId = null;\n    // First check if it's in snippet.parentId\n    if ((_comment_snippet = comment.snippet) === null || _comment_snippet === void 0 ? void 0 : _comment_snippet.parentId) {\n        parentId = comment.snippet.parentId;\n        console.log(\"Found parentId in snippet.parentId: \".concat(parentId));\n    } else if (((_comment_snippet1 = comment.snippet) === null || _comment_snippet1 === void 0 ? void 0 : (_comment_snippet_topLevelComment = _comment_snippet1.topLevelComment) === null || _comment_snippet_topLevelComment === void 0 ? void 0 : _comment_snippet_topLevelComment.id) && comment.id !== comment.snippet.topLevelComment.id) {\n        parentId = comment.snippet.topLevelComment.id;\n        console.log(\"Found parentId from topLevelComment: \".concat(parentId));\n    }\n    // If this is a direct API reply, it might be structured differently\n    if (((_comment_snippet2 = comment.snippet) === null || _comment_snippet2 === void 0 ? void 0 : _comment_snippet2.type) === \"reply\" && ((_comment_snippet3 = comment.snippet) === null || _comment_snippet3 === void 0 ? void 0 : _comment_snippet3.parentId)) {\n        parentId = comment.snippet.parentId;\n        console.log(\"Found parentId from reply type: \".concat(parentId));\n    }\n    // Log mapping for debugging\n    console.log(\"Mapping comment \".concat(comment.id, \", parentId: \").concat(parentId || \"NONE (top-level)\"));\n    return {\n        comment_id: comment.id,\n        video_id: comment.snippet.videoId,\n        author_name: ((_comment_snippet_topLevelComment1 = comment.snippet.topLevelComment) === null || _comment_snippet_topLevelComment1 === void 0 ? void 0 : (_comment_snippet_topLevelComment_snippet = _comment_snippet_topLevelComment1.snippet) === null || _comment_snippet_topLevelComment_snippet === void 0 ? void 0 : _comment_snippet_topLevelComment_snippet.authorDisplayName) || comment.snippet.authorDisplayName,\n        author_profile_url: ((_comment_snippet_topLevelComment2 = comment.snippet.topLevelComment) === null || _comment_snippet_topLevelComment2 === void 0 ? void 0 : (_comment_snippet_topLevelComment_snippet1 = _comment_snippet_topLevelComment2.snippet) === null || _comment_snippet_topLevelComment_snippet1 === void 0 ? void 0 : _comment_snippet_topLevelComment_snippet1.authorProfileImageUrl) || comment.snippet.authorProfileImageUrl,\n        text: ((_comment_snippet_topLevelComment3 = comment.snippet.topLevelComment) === null || _comment_snippet_topLevelComment3 === void 0 ? void 0 : (_comment_snippet_topLevelComment_snippet2 = _comment_snippet_topLevelComment3.snippet) === null || _comment_snippet_topLevelComment_snippet2 === void 0 ? void 0 : _comment_snippet_topLevelComment_snippet2.textDisplay) || comment.snippet.textDisplay,\n        like_count: ((_comment_snippet_topLevelComment4 = comment.snippet.topLevelComment) === null || _comment_snippet_topLevelComment4 === void 0 ? void 0 : (_comment_snippet_topLevelComment_snippet3 = _comment_snippet_topLevelComment4.snippet) === null || _comment_snippet_topLevelComment_snippet3 === void 0 ? void 0 : _comment_snippet_topLevelComment_snippet3.likeCount) || comment.snippet.likeCount || 0,\n        published_at: ((_comment_snippet_topLevelComment5 = comment.snippet.topLevelComment) === null || _comment_snippet_topLevelComment5 === void 0 ? void 0 : (_comment_snippet_topLevelComment_snippet4 = _comment_snippet_topLevelComment5.snippet) === null || _comment_snippet_topLevelComment_snippet4 === void 0 ? void 0 : _comment_snippet_topLevelComment_snippet4.publishedAt) || comment.snippet.publishedAt,\n        channel_id: channelId,\n        is_owner_comment: false,\n        parent_id: parentId,\n        video_title: comment.snippet.videoTitle || \"\"\n    };\n}\n// Enhanced mapping function that handles all possible properties\nfunction mapDbCommentToCommentData(dbComment) {\n    return {\n        id: dbComment.comment_id,\n        authorDisplayName: dbComment.author_name,\n        authorProfileImageUrl: dbComment.author_profile_url || \"https://www.gravatar.com/avatar/?d=mp\",\n        textDisplay: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.decodeAllHtmlEntities)(dbComment.text || \"\"),\n        likeCount: dbComment.like_count || 0,\n        publishedAt: dbComment.published_at,\n        updatedAt: dbComment.updated_at || dbComment.published_at,\n        videoId: dbComment.video_id,\n        videoTitle: dbComment.video_title || \"\",\n        replyCount: dbComment.reply_count || 0,\n        isHeartedByCreator: false,\n        isPinned: false,\n        parentId: dbComment.parent_id,\n        replies: []\n    };\n}\n// Add this debug function to the top of the file\nfunction logAllParentChildRelationships() {\n    return _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"comment_id, parent_id\").not(\"parent_id\", \"is\", null).limit(20).then((param)=>{\n        let { data, error } = param;\n        console.log(\"\\uD83D\\uDD0D PARENT-CHILD DEBUG - Sample comments with parents:\", data);\n        console.log(\"Error if any:\", error);\n        return data;\n    });\n}\n// Modified getCommentReplies function to fix reply lookup\nasync function getCommentReplies(commentId) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCommentReplies - Looking for replies to commentId:\", commentId);\n        // First, check if any comments in the database have parent_id matching our commentId\n        const { data: replyCheck, error: replyCheckError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"count(*)\").eq(\"parent_id\", commentId).single();\n        console.log(\"\\uD83D\\uDCCA getCommentReplies - Reply check result:\", replyCheck);\n        if (replyCheckError) {\n            console.error(\"❌ Reply check error:\", replyCheckError);\n        }\n        // Check the actual comment we're looking for replies to\n        const { data: parentComment, error: parentError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\").eq(\"comment_id\", commentId).single();\n        if (parentComment) {\n            console.log(\"✅ Found parent comment:\", {\n                id: parentComment.id,\n                comment_id: parentComment.comment_id,\n                video_id: parentComment.video_id,\n                text: parentComment.text.substring(0, 50) + \"...\"\n            });\n        } else {\n            console.log(\"⚠️ Parent comment not found for ID:\", commentId);\n        }\n        // Search for replies directly \n        const { data: replies, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\").eq(\"parent_id\", commentId) // This assumes parent_id references comment_id \n        .order(\"published_at\", {\n            ascending: true\n        });\n        if (error) {\n            console.error(\"❌ Error fetching replies:\", error);\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCCA Found \".concat((replies === null || replies === void 0 ? void 0 : replies.length) || 0, \" replies for comment:\"), commentId);\n        if (replies && replies.length > 0) {\n            // Sample the first reply\n            console.log(\"\\uD83D\\uDD0D First reply sample:\", {\n                id: replies[0].id,\n                comment_id: replies[0].comment_id,\n                parent_id: replies[0].parent_id,\n                video_id: replies[0].video_id,\n                text: replies[0].text.substring(0, 50) + \"...\"\n            });\n        }\n        // Map to the expected format\n        const replyData = (replies === null || replies === void 0 ? void 0 : replies.map((reply)=>mapDbCommentToCommentData(reply))) || [];\n        return replyData;\n    } catch (error) {\n        console.error(\"❌ Error in getCommentReplies:\", error);\n        return [];\n    }\n}\n// Get videos for a channel\nasync function getChannelVideos(channelId) {\n    try {\n        // Step 1: Get the internal UUID for this YouTube channel ID\n        const { data: channel } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"channels\").select(\"id\").eq(\"channel_id\", channelId).single();\n        if (!channel) {\n            console.log(\"Channel not found with ID:\", channelId);\n            return [];\n        }\n        console.log(\"Found channel, internal ID:\", channel.id);\n        // Step 2: Use the internal UUID to query videos\n        const { data: videos, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"videos\").select(\"*\").eq(\"channel_id\", channel.id); // Using internal UUID instead of YouTube channel ID\n        if (error) {\n            console.error(\"Error fetching videos:\", error);\n            throw error;\n        }\n        if (!videos || videos.length === 0) {\n            return [];\n        }\n        // Map DB videos to VideoData format\n        const videoData = videos.map((video)=>({\n                id: video.video_id,\n                title: video.title,\n                publishedAt: video.published_at,\n                thumbnailUrl: video.thumbnail_url,\n                channelId: video.channel_id\n            }));\n        return videoData;\n    } catch (error) {\n        console.error(\"Error in getChannelVideos:\", error);\n        return [];\n    }\n}\n// Add this function to inspect a comment record\nfunction inspectComment(comment) {\n    console.log(\"Comment structure:\", {\n        id: comment.id,\n        comment_id: comment.comment_id,\n        video_id: comment.video_id,\n        parent_id: comment.parent_id,\n        channel_id: comment.channel_id\n    });\n}\n// Update the getCommentThreads function with additional debugging\nasync function getCommentThreads(channelId, videoId) {\n    let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, perPage = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 20;\n    try {\n        console.log(\"\\uD83D\\uDD0E getCommentThreads - Inputs:\", {\n            channelId,\n            videoId,\n            page,\n            perPage\n        });\n        // Step 1: Get the internal UUID for this YouTube channel ID\n        const { data: channel, error: channelError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"channels\").select(\"*\").eq(\"channel_id\", channelId).single();\n        if (channelError) {\n            console.error(\"❌ getCommentThreads - Error finding channel:\", channelError);\n            return [];\n        }\n        if (!channel) {\n            console.log(\"⚠️ getCommentThreads - Channel not found with ID:\", channelId);\n            return [];\n        }\n        console.log(\"✅ getCommentThreads - Found channel:\", {\n            internal_id: channel.id,\n            channel_id: channel.channel_id,\n            title: channel.title\n        });\n        // Step 2: Use the internal UUID to query comments\n        const startIdx = (page - 1) * perPage;\n        const endIdx = page * perPage - 1;\n        console.log(\"\\uD83D\\uDD22 getCommentThreads - Range: \".concat(startIdx, \" to \").concat(endIdx));\n        let query = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\").eq(\"channel_id\", channel.id).is(\"parent_id\", null) // Only get top-level comments\n        .order(\"published_at\", {\n            ascending: false\n        }).range(startIdx, endIdx);\n        if (videoId) {\n            query = query.eq(\"video_id\", videoId);\n        }\n        const { data: comments, error: commentsError } = await query;\n        if (commentsError) {\n            console.error(\"❌ getCommentThreads - Error fetching comments:\", commentsError);\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCCA getCommentThreads - Found \".concat((comments === null || comments === void 0 ? void 0 : comments.length) || 0, \" comments\"));\n        if (!comments || comments.length === 0) {\n            return [];\n        }\n        // Sample the first comment to debug\n        if (comments.length > 0) {\n            console.log(\"\\uD83D\\uDD0D getCommentThreads - First comment:\", {\n                id: comments[0].id,\n                comment_id: comments[0].comment_id,\n                parent_id: comments[0].parent_id,\n                channel_id: comments[0].channel_id\n            });\n        }\n        // For each comment, count replies and map to CommentData format\n        const commentData = await Promise.all(comments.map(async (comment)=>{\n            // Count replies for this comment \n            const { count } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"parent_id\", comment.comment_id);\n            const replyCount = count || 0;\n            // Map DB comment to CommentData format with reply count\n            return {\n                ...mapDbCommentToCommentData(comment),\n                replyCount\n            };\n        }));\n        return commentData;\n    } catch (error) {\n        console.error(\"❌ getCommentThreads - Unhandled error:\", error);\n        return [];\n    }\n}\nasync function updateCommentReplyCounts() {\n    console.log(\"Updating reply counts for all comments...\");\n    try {\n        // For each comment with replies, count them and update the reply_count\n        const { data: comments } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"comment_id\").is(\"parent_id\", null);\n        if (!comments) return;\n        for (const comment of comments){\n            // Count the replies for this comment\n            const { count } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").select(\"*\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"parent_id\", comment.comment_id);\n            // Update the reply_count\n            if (count !== undefined) {\n                await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"comments\").update({\n                    reply_count: count\n                }).eq(\"comment_id\", comment.comment_id);\n            }\n        }\n        console.log(\"Reply counts updated successfully\");\n    } catch (error) {\n        console.error(\"Error updating reply counts:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi95b3V0dWJlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU3NDO0FBRThCO0FBRXBFOzs7O0NBSUMsR0FFRDs7Ozs7Q0FLQyxHQUNNLGVBQWVFLGlCQUFpQkMsV0FBbUIsRUFBRUMsTUFBYztJQUN4RSxNQUFNQyxNQUFNLCtEQUFtSEQsT0FBcERFLG1CQUFtQkgsY0FBYSxzQkFBMkIsT0FBUEM7SUFDL0gsTUFBTUcsV0FBVyxNQUFNQyxNQUFNSDtJQUM3QixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7SUFFaEMsSUFBSSxDQUFDRCxLQUFLRSxLQUFLLElBQUlGLEtBQUtFLEtBQUssQ0FBQ0MsTUFBTSxLQUFLLEdBQUc7UUFDMUMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsT0FBT0osS0FBS0UsS0FBSyxDQUFDLEVBQUUsQ0FBQ0csRUFBRSxDQUFDQyxTQUFTO0FBQ25DO0FBRUE7O0NBRUMsR0FDTSxlQUFlQyxxQkFDcEJELFNBQWlCLEVBQ2pCWCxNQUFjO1FBQ2RhLGFBQUFBLGlFQUFxQixJQUNyQkM7SUFFQSxNQUFNYixNQUFNLHVFQUErRlksT0FBeEJGLFdBQVUsZ0JBQXNEWCxPQUF4Q2EsWUFBVywrQkFBc0NDLE9BQVRkLFFBQW9ELE9BQTNDYyxZQUFZLGNBQXdCLE9BQVZBLGFBQWM7SUFDcE0sTUFBTVgsV0FBVyxNQUFNQyxNQUFNSDtJQUM3QixPQUFPLE1BQU1FLFNBQVNHLElBQUk7QUFDNUI7QUFFQTs7Q0FFQyxHQUNNLGVBQWVTLHdCQUNwQkosU0FBaUIsRUFDakJYLE1BQWM7SUFFZCxJQUFJZ0IsWUFBNEIsRUFBRTtJQUNsQyxJQUFJQztJQUVKLEdBQUc7UUFDREMsUUFBUUMsR0FBRyxDQUFDLCtCQUEyQ0YsT0FBWk4sV0FBbUUsT0FBdkRNLGdCQUFnQixpQkFBK0IsT0FBZEEsZUFBYyxPQUFLO1FBQzNHLE1BQU1kLFdBQVcsTUFBTVMscUJBQXFCRCxXQUFXWCxRQUFRLElBQUlp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WUFFckMsTUFBTW9CLGFBQWEyQyxTQUFTO1lBRTVCLHdEQUF3RDtZQUN4RCxPQUFPO2dCQUNMLEdBQUcvQywwQkFBMEI1QixRQUFRO2dCQUNyQ2dDO1lBQ0Y7UUFDRjtRQUdGLE9BQU95QztJQUNULEVBQUUsT0FBTzlGLE9BQU87UUFDZFQsUUFBUVMsS0FBSyxDQUFDLDBDQUEwQ0E7UUFDeEQsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVPLGVBQWVrRztJQUNwQjNHLFFBQVFDLEdBQUcsQ0FBQztJQUVaLElBQUk7UUFDRix1RUFBdUU7UUFDdkUsTUFBTSxFQUFFZCxNQUFNc0MsUUFBUSxFQUFFLEdBQUcsTUFBTS9DLCtDQUFRQSxDQUN0Q3lGLElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMsY0FDUGdDLEVBQUUsQ0FBQyxhQUFhO1FBRW5CLElBQUksQ0FBQzNFLFVBQVU7UUFFZixLQUFLLE1BQU1LLFdBQVdMLFNBQVU7WUFDOUIscUNBQXFDO1lBQ3JDLE1BQU0sRUFBRWdGLEtBQUssRUFBRSxHQUFHLE1BQU0vSCwrQ0FBUUEsQ0FDN0J5RixJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFDLEtBQUs7Z0JBQUVxQyxPQUFPO2dCQUFTQyxNQUFNO1lBQUssR0FDekM5QixFQUFFLENBQUMsYUFBYTlDLFFBQVFZLFVBQVU7WUFFckMseUJBQXlCO1lBQ3pCLElBQUkrRCxVQUFVRyxXQUFXO2dCQUN2QixNQUFNbEksK0NBQVFBLENBQ1h5RixJQUFJLENBQUMsWUFDTDBDLE1BQU0sQ0FBQztvQkFBRTlDLGFBQWEwQztnQkFBTSxHQUM1QjdCLEVBQUUsQ0FBQyxjQUFjOUMsUUFBUVksVUFBVTtZQUN4QztRQUNGO1FBRUExQyxRQUFRQyxHQUFHLENBQUM7SUFDZCxFQUFFLE9BQU9RLE9BQU87UUFDZFQsUUFBUVMsS0FBSyxDQUFDLGdDQUFnQ0E7SUFDaEQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIveW91dHViZS50cz8zMjIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBZb3VUdWJlQ2hhbm5lbCwgXG4gIFlvdVR1YmVWaWRlbywgXG4gIFlvdVR1YmVDb21tZW50LFxuICBZb3VUdWJlQ2hhbm5lbFJlc3BvbnNlLFxuICBZb3VUdWJlVmlkZW9SZXNwb25zZSxcbiAgWW91VHViZUNvbW1lbnRSZXNwb25zZSxcbiAgRGJDb21tZW50IFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBDb21tZW50RGF0YSwgVmlkZW9EYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBkZWNvZGVIdG1sRW50aXRpZXMsIGRlY29kZUFsbEh0bWxFbnRpdGllcyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFlvdVR1YmUgQVBJIGludGVncmF0aW9uIGZvciBmZXRjaGluZyBjaGFubmVsIGRhdGEgYW5kIGNvbW1lbnRzXG4gKiBCYXNlZCBvbiB0aGUgWW91VHViZSBEYXRhIEFQSSB2MyBkb2N1bWVudGF0aW9uOiBcbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvdjMvZG9jc1xuICovXG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIGEgWW91VHViZSBjaGFubmVsIGJ5IG5hbWVcbiAqIEBwYXJhbSBjaGFubmVsTmFtZSBUaGUgbmFtZSBvZiB0aGUgY2hhbm5lbCB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0gYXBpS2V5IFlvdVR1YmUgQVBJIGtleVxuICogQHJldHVybnMgVGhlIGNoYW5uZWwgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaEZvckNoYW5uZWwoY2hhbm5lbE5hbWU6IHN0cmluZywgYXBpS2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCB1cmwgPSBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20veW91dHViZS92My9zZWFyY2g/cGFydD1zbmlwcGV0JnE9JHtlbmNvZGVVUklDb21wb25lbnQoY2hhbm5lbE5hbWUpfSZ0eXBlPWNoYW5uZWwma2V5PSR7YXBpS2V5fWA7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgXG4gIGlmICghZGF0YS5pdGVtcyB8fCBkYXRhLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBub3QgZm91bmQnKTtcbiAgfVxuICBcbiAgcmV0dXJuIGRhdGEuaXRlbXNbMF0uaWQuY2hhbm5lbElkO1xufVxuXG4vKipcbiAqIEZldGNoZXMgdmlkZW9zIGZvciBhIFlvdVR1YmUgY2hhbm5lbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hWaWRlb3NCeUNoYW5uZWwoXG4gIGNoYW5uZWxJZDogc3RyaW5nLCBcbiAgYXBpS2V5OiBzdHJpbmcsIFxuICBtYXhSZXN1bHRzOiBudW1iZXIgPSA1MCxcbiAgcGFnZVRva2VuPzogc3RyaW5nXG4pOiBQcm9taXNlPFlvdVR1YmVWaWRlb1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHVybCA9IGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS95b3V0dWJlL3YzL3NlYXJjaD9wYXJ0PXNuaXBwZXQmY2hhbm5lbElkPSR7Y2hhbm5lbElkfSZtYXhSZXN1bHRzPSR7bWF4UmVzdWx0c30mb3JkZXI9ZGF0ZSZ0eXBlPXZpZGVvJmtleT0ke2FwaUtleX0ke3BhZ2VUb2tlbiA/IGAmcGFnZVRva2VuPSR7cGFnZVRva2VufWAgOiAnJ31gO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59XG5cbi8qKlxuICogRmV0Y2hlcyBhbGwgdmlkZW9zIGZvciBhIFlvdVR1YmUgY2hhbm5lbCB3aXRoIHBhZ2luYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQWxsVmlkZW9zQnlDaGFubmVsKFxuICBjaGFubmVsSWQ6IHN0cmluZywgXG4gIGFwaUtleTogc3RyaW5nXG4pOiBQcm9taXNlPFlvdVR1YmVWaWRlb1tdPiB7XG4gIGxldCBhbGxWaWRlb3M6IFlvdVR1YmVWaWRlb1tdID0gW107XG4gIGxldCBuZXh0UGFnZVRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIFxuICBkbyB7XG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIHZpZGVvcyBmb3IgY2hhbm5lbCAke2NoYW5uZWxJZH0ke25leHRQYWdlVG9rZW4gPyBgIChwYWdlIHRva2VuOiAke25leHRQYWdlVG9rZW59KWAgOiAnJ31gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoVmlkZW9zQnlDaGFubmVsKGNoYW5uZWxJZCwgYXBpS2V5LCA1MCwgbmV4dFBhZ2VUb2tlbik7XG4gICAgYWxsVmlkZW9zID0gWy4uLmFsbFZpZGVvcywgLi4uKHJlc3BvbnNlLml0ZW1zIHx8IFtdKV07XG4gICAgbmV4dFBhZ2VUb2tlbiA9IHJlc3BvbnNlLm5leHRQYWdlVG9rZW47XG4gICAgXG4gICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgdG8gYXZvaWQgQVBJIHJhdGUgbGltaXRzXG4gICAgaWYgKG5leHRQYWdlVG9rZW4pIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICB9XG4gIH0gd2hpbGUgKG5leHRQYWdlVG9rZW4pO1xuICBcbiAgcmV0dXJuIGFsbFZpZGVvcztcbn1cblxuLyoqXG4gKiBGZXRjaGVzIGNvbW1lbnRzIGZvciBhIHNwZWNpZmljIHZpZGVvXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaENvbW1lbnRzKFxuICB2aWRlb0lkOiBzdHJpbmcsIFxuICBhcGlLZXk6IHN0cmluZywgXG4gIHBhZ2VUb2tlbj86IHN0cmluZ1xuKTogUHJvbWlzZTxZb3VUdWJlQ29tbWVudFJlc3BvbnNlPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3lvdXR1YmUvdjMvY29tbWVudFRocmVhZHM/cGFydD1zbmlwcGV0LHJlcGxpZXMmdmlkZW9JZD0ke3ZpZGVvSWR9Jm1heFJlc3VsdHM9MTAwJmtleT0ke2FwaUtleX0ke3BhZ2VUb2tlbiA/IGAmcGFnZVRva2VuPSR7cGFnZVRva2VufWAgOiAnJ31gO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjb21tZW50czogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvbW1lbnRzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoZXMgdGhlIGxhdGVzdCBjb21tZW50cyBmcm9tIGEgWW91VHViZSBjaGFubmVsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaExhdGVzdENoYW5uZWxDb21tZW50cyhcbiAgY2hhbm5lbElkOiBzdHJpbmcsXG4gIGFwaUtleTogc3RyaW5nLFxuICBtYXhWaWRlb3M6IG51bWJlciA9IDEwLFxuICBpbmNsdWRlT2xkVmlkZW9zOiBib29sZWFuID0gZmFsc2UsXG4gIG1heENvbW1lbnRzOiBudW1iZXIgPSAxMDAwLFxuICBpbmNsdWRlUmVwbGllczogYm9vbGVhbiA9IHRydWVcbik6IFByb21pc2U8WW91VHViZUNvbW1lbnRbXT4ge1xuICAvLyBGZXRjaCB2aWRlb3MgZmlyc3RcbiAgY29uc29sZS5sb2coYEZldGNoaW5nIHZpZGVvcyBmb3IgY2hhbm5lbCAke2NoYW5uZWxJZH1gKTtcbiAgbGV0IHZpZGVvc1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2hWaWRlb3NCeUNoYW5uZWwoY2hhbm5lbElkLCBhcGlLZXkpO1xuICBsZXQgcHJvY2Vzc2VkVmlkZW9zID0gdmlkZW9zUmVzcG9uc2UuaXRlbXMgfHwgW107XG4gIFxuICAvLyBJZiB3ZSBzaG91bGQgaW5jbHVkZSBvbGRlciB2aWRlb3MgYmV5b25kIHRoZSBmaXJzdCBwYWdlXG4gIGlmIChpbmNsdWRlT2xkVmlkZW9zICYmIHZpZGVvc1Jlc3BvbnNlLm5leHRQYWdlVG9rZW4pIHtcbiAgICBjb25zb2xlLmxvZygnSW5jbHVkaW5nIG9sZGVyIHZpZGVvcycpO1xuICAgIGNvbnN0IGFsbFZpZGVvcyA9IGF3YWl0IGZldGNoQWxsVmlkZW9zQnlDaGFubmVsKGNoYW5uZWxJZCwgYXBpS2V5KTtcbiAgICBwcm9jZXNzZWRWaWRlb3MgPSBhbGxWaWRlb3M7XG4gICAgXG4gICAgLy8gTGltaXQgdG8gbW9zdCByZWNlbnQgdmlkZW9zXG4gICAgaWYgKG1heFZpZGVvcyAhPT0gLTEpIHtcbiAgICAgIHByb2Nlc3NlZFZpZGVvcyA9IHByb2Nlc3NlZFZpZGVvcy5zbGljZSgwLCBtYXhWaWRlb3MpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRmV0Y2ggY29tbWVudHMgZm9yIGVhY2ggdmlkZW9cbiAgbGV0IGFsbENvbW1lbnRzOiBZb3VUdWJlQ29tbWVudFtdID0gW107XG4gIGxldCB0b3RhbENvbW1lbnRzQWRkZWQgPSAwO1xuICBcbiAgZm9yIChjb25zdCB2aWRlbyBvZiBwcm9jZXNzZWRWaWRlb3MpIHtcbiAgICBjb25zdCB2aWRlb0lkID0gdHlwZW9mIHZpZGVvLmlkID09PSAnc3RyaW5nJyBcbiAgICAgID8gdmlkZW8uaWQgXG4gICAgICA6ICh2aWRlby5pZCBhcyBhbnkpPy52aWRlb0lkIHx8ICh2aWRlby5pZCBhcyBhbnkpPy5yZXNvdXJjZUlkPy52aWRlb0lkO1xuICAgICAgXG4gICAgY29uc3QgdmlkZW9UaXRsZSA9IHZpZGVvLnNuaXBwZXQudGl0bGU7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb21tZW50czogWW91VHViZUNvbW1lbnRbXSA9IFtdO1xuICAgICAgbGV0IGNvbW1lbnROZXh0UGFnZVRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBcbiAgICAgIC8vIEdldCBjb21tZW50cyB1bnRpbCB3ZSByZWFjaCBtYXhDb21tZW50cyBvciBydW4gb3V0IG9mIHBhZ2VzXG4gICAgICBsZXQgY29tbWVudFBhZ2VzID0gMDtcbiAgICAgIFxuICAgICAgZG8ge1xuICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgY29tbWVudHMgZm9yIHZpZGVvOiAke3ZpZGVvVGl0bGV9IChwYWdlICR7Y29tbWVudFBhZ2VzICsgMX0pYCk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRSZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHModmlkZW9JZCwgYXBpS2V5LCBjb21tZW50TmV4dFBhZ2VUb2tlbik7XG4gICAgICAgIGNvbnN0IHZpZGVvQ29tbWVudHMgPSBjb21tZW50UmVzcG9uc2UuaXRlbXMgfHwgW107XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZWFjaCBjb21tZW50XG4gICAgICAgIGZvciAoY29uc3QgY29tbWVudCBvZiB2aWRlb0NvbW1lbnRzKSB7XG4gICAgICAgICAgLy8gQWRkIHZpZGVvIHRpdGxlIGZvciBjb250ZXh0XG4gICAgICAgICAgY29uc3QgZW5yaWNoZWRDb21tZW50OiBZb3VUdWJlQ29tbWVudCA9IHtcbiAgICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgICBzbmlwcGV0OiB7XG4gICAgICAgICAgICAgIC4uLmNvbW1lbnQuc25pcHBldCxcbiAgICAgICAgICAgICAgdmlkZW9UaXRsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29tbWVudHMucHVzaChlbnJpY2hlZENvbW1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCByZXBsaWVzIGlmIHJlcXVlc3RlZCBhbmQgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKGluY2x1ZGVSZXBsaWVzICYmIGNvbW1lbnQucmVwbGllcyAmJiBjb21tZW50LnJlcGxpZXMuY29tbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVwbHkgb2YgY29tbWVudC5yZXBsaWVzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgIC8vIEZvcm1hdCByZXBseSBhcyBhIFlvdVR1YmVDb21tZW50XG4gICAgICAgICAgICAgIGNvbnN0IHJlcGx5Q29tbWVudDogWW91VHViZUNvbW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHJlcGx5LmlkLFxuICAgICAgICAgICAgICAgIHNuaXBwZXQ6IHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvSWQsXG4gICAgICAgICAgICAgICAgICB0b3BMZXZlbENvbW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc25pcHBldDogcmVwbHkuc25pcHBldFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHZpZGVvVGl0bGUsXG4gICAgICAgICAgICAgICAgICBwYXJlbnRJZDogY29tbWVudC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29tbWVudHMucHVzaChyZXBseUNvbW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29tbWVudE5leHRQYWdlVG9rZW4gPSBjb21tZW50UmVzcG9uc2UubmV4dFBhZ2VUb2tlbjtcbiAgICAgICAgY29tbWVudFBhZ2VzKys7XG4gICAgICAgIFxuICAgICAgICAvLyBDb250aW51ZSBmZXRjaGluZyBtb3JlIHBhZ2VzIGlmIGF2YWlsYWJsZSBhbmQgd2l0aGluIGxpbWl0c1xuICAgICAgICBpZiAoY29tbWVudE5leHRQYWdlVG9rZW4gJiYgKG1heENvbW1lbnRzID09PSAtMSB8fCB0b3RhbENvbW1lbnRzQWRkZWQgKyBjb21tZW50cy5sZW5ndGggPCBtYXhDb21tZW50cykpIHtcbiAgICAgICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBhdm9pZCBBUEkgcmF0ZSBsaW1pdHNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYE1vcmUgY29tbWVudHMgYXZhaWxhYmxlIGZvciAke3ZpZGVvVGl0bGV9LCBmZXRjaGluZyBwYWdlICR7Y29tbWVudFBhZ2VzICsgMX0uLi5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY29tbWVudE5leHRQYWdlVG9rZW4pO1xuICAgICAgXG4gICAgICBhbGxDb21tZW50cyA9IFsuLi5hbGxDb21tZW50cywgLi4uY29tbWVudHNdO1xuICAgICAgdG90YWxDb21tZW50c0FkZGVkICs9IGNvbW1lbnRzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgLy8gU3RvcCBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjb21tZW50c1xuICAgICAgaWYgKG1heENvbW1lbnRzICE9PSAtMSAmJiB0b3RhbENvbW1lbnRzQWRkZWQgPj0gbWF4Q29tbWVudHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFJlYWNoZWQgbWF4aW11bSBvZiAke21heENvbW1lbnRzfSBjb21tZW50c2ApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY29tbWVudHMgZm9yIHZpZGVvICR7dmlkZW9JZH06YCwgZXJyb3IpO1xuICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciB2aWRlb3NcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBhbGxDb21tZW50cztcbn1cblxuLyoqXG4gKiBHZXQgWW91VHViZSBjb21tZW50cyBmb3IgYSB2aWRlb1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29tbWVudHNGb3JWaWRlbyhcbiAgdmlkZW9JZDogc3RyaW5nLCBcbiAgYXBpS2V5OiBzdHJpbmcsIFxuICBtYXhDb21tZW50czogbnVtYmVyID0gLTEsXG4gIGluY2x1ZGVSZXBsaWVzOiBib29sZWFuID0gdHJ1ZVxuKSB7XG4gIGNvbnNvbGUubG9nKGBHZXR0aW5nIGNvbW1lbnRzIGZvciB2aWRlbyAke3ZpZGVvSWR9LCBpbmNsdWRpbmcgcmVwbGllczogJHtpbmNsdWRlUmVwbGllc31gKTtcbiAgXG4gIGxldCBjb21tZW50czogWW91VHViZUNvbW1lbnRbXSA9IFtdO1xuICBsZXQgbmV4dFBhZ2VUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBsZXQgY29tbWVudENvdW50ID0gMDtcbiAgXG4gIGRvIHtcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgY29tbWVudHMgcGFnZSAke2NvbW1lbnRDb3VudCA+IDAgPyBjb21tZW50Q291bnQgLyAyMCArIDEgOiAxfWApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50cyh2aWRlb0lkLCBhcGlLZXksIG5leHRQYWdlVG9rZW4pO1xuICAgIGNvbnN0IHZpZGVvQ29tbWVudHMgPSByZXNwb25zZS5pdGVtcyB8fCBbXTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIGVhY2ggdG9wLWxldmVsIGNvbW1lbnRcbiAgICBmb3IgKGNvbnN0IGNvbW1lbnQgb2YgdmlkZW9Db21tZW50cykge1xuICAgICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgIGNvbW1lbnRDb3VudCsrO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIHJlcGxpZXMgaWYgYXZhaWxhYmxlIGFuZCByZXF1ZXN0ZWRcbiAgICAgIGlmIChpbmNsdWRlUmVwbGllcyAmJiBjb21tZW50LnJlcGxpZXMgJiYgY29tbWVudC5yZXBsaWVzLmNvbW1lbnRzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2NvbW1lbnQucmVwbGllcy5jb21tZW50cy5sZW5ndGh9IHJlcGxpZXMgZm9yIGNvbW1lbnQgJHtjb21tZW50LmlkfWApO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCByZXBseSBvZiBjb21tZW50LnJlcGxpZXMuY29tbWVudHMpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhlIHJlcGx5IGhhcyBhIHByb3Blcmx5IGZvcm1hdHRlZCBwYXJlbnRfaWRcbiAgICAgICAgICBjb25zdCByZXBseUNvbW1lbnQgPSB7XG4gICAgICAgICAgICAuLi5yZXBseSxcbiAgICAgICAgICAgIHNuaXBwZXQ6IHtcbiAgICAgICAgICAgICAgLi4ucmVwbHkuc25pcHBldCxcbiAgICAgICAgICAgICAgcGFyZW50SWQ6IGNvbW1lbnQuaWQsICAvLyBFeHBsaWNpdGx5IHNldCB0aGUgcGFyZW50IElEIHRvIHRoZSB0b3AtbGV2ZWwgY29tbWVudFxuICAgICAgICAgICAgICB2aWRlb0lkOiB2aWRlb0lkICAgICAgIC8vIEVuc3VyZSB2aWRlb0lkIGlzIGluY2x1ZGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb21tZW50cy5wdXNoKHJlcGx5Q29tbWVudCk7XG4gICAgICAgICAgY29tbWVudENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgbmV4dFBhZ2VUb2tlbiA9IHJlc3BvbnNlLm5leHRQYWdlVG9rZW47XG4gICAgXG4gICAgLy8gQ29udGludWUgdW50aWwgd2UndmUgcmVhY2hlZCBtYXggY29tbWVudHMgb3IgcnVuIG91dCBvZiBwYWdlc1xuICAgIGlmIChtYXhDb21tZW50cyAhPT0gLTEgJiYgY29tbWVudENvdW50ID49IG1heENvbW1lbnRzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUmVhY2hlZCBtYXhpbXVtIG9mICR7bWF4Q29tbWVudHN9IGNvbW1lbnRzYCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgLy8gU21hbGwgZGVsYXkgdG8gYXZvaWQgcmF0ZSBsaW1pdGluZ1xuICAgIGlmIChuZXh0UGFnZVRva2VuKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgfVxuICB9IHdoaWxlIChuZXh0UGFnZVRva2VuKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBSZXRyaWV2ZWQgJHtjb21tZW50cy5sZW5ndGh9IGNvbW1lbnRzIHRvdGFsYCk7XG4gIHJldHVybiBjb21tZW50cztcbn1cblxuLy8gVXBkYXRlZCBtYXBZb3VUdWJlQ29tbWVudFRvRGJDb21tZW50IGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gbWFwWW91VHViZUNvbW1lbnRUb0RiQ29tbWVudChjb21tZW50OiBhbnksIGNoYW5uZWxJZDogc3RyaW5nKTogRGJDb21tZW50IHtcbiAgLy8gVmVyeSBleHBsaWNpdGx5IGV4dHJhY3QgcGFyZW50SWQgZnJvbSBhbGwgcG9zc2libGUgbG9jYXRpb25zXG4gIGxldCBwYXJlbnRJZCA9IG51bGw7XG4gIFxuICAvLyBGaXJzdCBjaGVjayBpZiBpdCdzIGluIHNuaXBwZXQucGFyZW50SWRcbiAgaWYgKGNvbW1lbnQuc25pcHBldD8ucGFyZW50SWQpIHtcbiAgICBwYXJlbnRJZCA9IGNvbW1lbnQuc25pcHBldC5wYXJlbnRJZDtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgcGFyZW50SWQgaW4gc25pcHBldC5wYXJlbnRJZDogJHtwYXJlbnRJZH1gKTtcbiAgfSBcbiAgLy8gVGhlbiBjaGVjayByZXBseSBzdHJ1Y3R1cmVcbiAgZWxzZSBpZiAoY29tbWVudC5zbmlwcGV0Py50b3BMZXZlbENvbW1lbnQ/LmlkICYmIGNvbW1lbnQuaWQgIT09IGNvbW1lbnQuc25pcHBldC50b3BMZXZlbENvbW1lbnQuaWQpIHtcbiAgICBwYXJlbnRJZCA9IGNvbW1lbnQuc25pcHBldC50b3BMZXZlbENvbW1lbnQuaWQ7XG4gICAgY29uc29sZS5sb2coYEZvdW5kIHBhcmVudElkIGZyb20gdG9wTGV2ZWxDb21tZW50OiAke3BhcmVudElkfWApO1xuICB9XG4gIFxuICAvLyBJZiB0aGlzIGlzIGEgZGlyZWN0IEFQSSByZXBseSwgaXQgbWlnaHQgYmUgc3RydWN0dXJlZCBkaWZmZXJlbnRseVxuICBpZiAoY29tbWVudC5zbmlwcGV0Py50eXBlID09PSAncmVwbHknICYmIGNvbW1lbnQuc25pcHBldD8ucGFyZW50SWQpIHtcbiAgICBwYXJlbnRJZCA9IGNvbW1lbnQuc25pcHBldC5wYXJlbnRJZDtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgcGFyZW50SWQgZnJvbSByZXBseSB0eXBlOiAke3BhcmVudElkfWApO1xuICB9XG4gIFxuICAvLyBMb2cgbWFwcGluZyBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUubG9nKGBNYXBwaW5nIGNvbW1lbnQgJHtjb21tZW50LmlkfSwgcGFyZW50SWQ6ICR7cGFyZW50SWQgfHwgJ05PTkUgKHRvcC1sZXZlbCknfWApO1xuICBcbiAgcmV0dXJuIHtcbiAgICBjb21tZW50X2lkOiBjb21tZW50LmlkLFxuICAgIHZpZGVvX2lkOiBjb21tZW50LnNuaXBwZXQudmlkZW9JZCxcbiAgICBhdXRob3JfbmFtZTogY29tbWVudC5zbmlwcGV0LnRvcExldmVsQ29tbWVudD8uc25pcHBldD8uYXV0aG9yRGlzcGxheU5hbWUgfHwgY29tbWVudC5zbmlwcGV0LmF1dGhvckRpc3BsYXlOYW1lLFxuICAgIGF1dGhvcl9wcm9maWxlX3VybDogY29tbWVudC5zbmlwcGV0LnRvcExldmVsQ29tbWVudD8uc25pcHBldD8uYXV0aG9yUHJvZmlsZUltYWdlVXJsIHx8IGNvbW1lbnQuc25pcHBldC5hdXRob3JQcm9maWxlSW1hZ2VVcmwsXG4gICAgdGV4dDogY29tbWVudC5zbmlwcGV0LnRvcExldmVsQ29tbWVudD8uc25pcHBldD8udGV4dERpc3BsYXkgfHwgY29tbWVudC5zbmlwcGV0LnRleHREaXNwbGF5LFxuICAgIGxpa2VfY291bnQ6IGNvbW1lbnQuc25pcHBldC50b3BMZXZlbENvbW1lbnQ/LnNuaXBwZXQ/Lmxpa2VDb3VudCB8fCBjb21tZW50LnNuaXBwZXQubGlrZUNvdW50IHx8IDAsXG4gICAgcHVibGlzaGVkX2F0OiBjb21tZW50LnNuaXBwZXQudG9wTGV2ZWxDb21tZW50Py5zbmlwcGV0Py5wdWJsaXNoZWRBdCB8fCBjb21tZW50LnNuaXBwZXQucHVibGlzaGVkQXQsXG4gICAgY2hhbm5lbF9pZDogY2hhbm5lbElkLFxuICAgIGlzX293bmVyX2NvbW1lbnQ6IGZhbHNlLFxuICAgIHBhcmVudF9pZDogcGFyZW50SWQsXG4gICAgdmlkZW9fdGl0bGU6IGNvbW1lbnQuc25pcHBldC52aWRlb1RpdGxlIHx8ICcnLFxuICB9O1xufVxuXG4vLyBFbmhhbmNlZCBtYXBwaW5nIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBhbGwgcG9zc2libGUgcHJvcGVydGllc1xuZXhwb3J0IGZ1bmN0aW9uIG1hcERiQ29tbWVudFRvQ29tbWVudERhdGEoZGJDb21tZW50OiBhbnkpOiBDb21tZW50RGF0YSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGRiQ29tbWVudC5jb21tZW50X2lkLFxuICAgIGF1dGhvckRpc3BsYXlOYW1lOiBkYkNvbW1lbnQuYXV0aG9yX25hbWUsXG4gICAgYXV0aG9yUHJvZmlsZUltYWdlVXJsOiBkYkNvbW1lbnQuYXV0aG9yX3Byb2ZpbGVfdXJsIHx8ICdodHRwczovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyLz9kPW1wJyxcbiAgICB0ZXh0RGlzcGxheTogZGVjb2RlQWxsSHRtbEVudGl0aWVzKGRiQ29tbWVudC50ZXh0IHx8ICcnKSxcbiAgICBsaWtlQ291bnQ6IGRiQ29tbWVudC5saWtlX2NvdW50IHx8IDAsXG4gICAgcHVibGlzaGVkQXQ6IGRiQ29tbWVudC5wdWJsaXNoZWRfYXQsXG4gICAgdXBkYXRlZEF0OiBkYkNvbW1lbnQudXBkYXRlZF9hdCB8fCBkYkNvbW1lbnQucHVibGlzaGVkX2F0LFxuICAgIHZpZGVvSWQ6IGRiQ29tbWVudC52aWRlb19pZCxcbiAgICB2aWRlb1RpdGxlOiBkYkNvbW1lbnQudmlkZW9fdGl0bGUgfHwgJycsXG4gICAgcmVwbHlDb3VudDogZGJDb21tZW50LnJlcGx5X2NvdW50IHx8IDAsXG4gICAgaXNIZWFydGVkQnlDcmVhdG9yOiBmYWxzZSxcbiAgICBpc1Bpbm5lZDogZmFsc2UsXG4gICAgcGFyZW50SWQ6IGRiQ29tbWVudC5wYXJlbnRfaWQsXG4gICAgcmVwbGllczogW11cbiAgfTtcbn1cblxuLy8gQWRkIHRoaXMgZGVidWcgZnVuY3Rpb24gdG8gdGhlIHRvcCBvZiB0aGUgZmlsZVxuZnVuY3Rpb24gbG9nQWxsUGFyZW50Q2hpbGRSZWxhdGlvbnNoaXBzKCkge1xuICByZXR1cm4gc3VwYWJhc2VcbiAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgIC5zZWxlY3QoJ2NvbW1lbnRfaWQsIHBhcmVudF9pZCcpXG4gICAgLm5vdCgncGFyZW50X2lkJywgJ2lzJywgbnVsbClcbiAgICAubGltaXQoMjApXG4gICAgLnRoZW4oKHsgZGF0YSwgZXJyb3IgfSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gUEFSRU5ULUNISUxEIERFQlVHIC0gU2FtcGxlIGNvbW1lbnRzIHdpdGggcGFyZW50czonLCBkYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBpZiBhbnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59XG5cbi8vIE1vZGlmaWVkIGdldENvbW1lbnRSZXBsaWVzIGZ1bmN0aW9uIHRvIGZpeCByZXBseSBsb29rdXBcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21tZW50UmVwbGllcyhjb21tZW50SWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIGdldENvbW1lbnRSZXBsaWVzIC0gTG9va2luZyBmb3IgcmVwbGllcyB0byBjb21tZW50SWQ6JywgY29tbWVudElkKTtcbiAgICBcbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgYW55IGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSBoYXZlIHBhcmVudF9pZCBtYXRjaGluZyBvdXIgY29tbWVudElkXG4gICAgY29uc3QgeyBkYXRhOiByZXBseUNoZWNrLCBlcnJvcjogcmVwbHlDaGVja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgIC5zZWxlY3QoJ2NvdW50KCopJylcbiAgICAgIC5lcSgncGFyZW50X2lkJywgY29tbWVudElkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogZ2V0Q29tbWVudFJlcGxpZXMgLSBSZXBseSBjaGVjayByZXN1bHQ6JywgcmVwbHlDaGVjayk7XG4gICAgXG4gICAgaWYgKHJlcGx5Q2hlY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFJlcGx5IGNoZWNrIGVycm9yOicsIHJlcGx5Q2hlY2tFcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHRoZSBhY3R1YWwgY29tbWVudCB3ZSdyZSBsb29raW5nIGZvciByZXBsaWVzIHRvXG4gICAgY29uc3QgeyBkYXRhOiBwYXJlbnRDb21tZW50LCBlcnJvcjogcGFyZW50RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NvbW1lbnRfaWQnLCBjb21tZW50SWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICBpZiAocGFyZW50Q29tbWVudCkge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBGb3VuZCBwYXJlbnQgY29tbWVudDonLCB7XG4gICAgICAgIGlkOiBwYXJlbnRDb21tZW50LmlkLFxuICAgICAgICBjb21tZW50X2lkOiBwYXJlbnRDb21tZW50LmNvbW1lbnRfaWQsXG4gICAgICAgIHZpZGVvX2lkOiBwYXJlbnRDb21tZW50LnZpZGVvX2lkLFxuICAgICAgICB0ZXh0OiBwYXJlbnRDb21tZW50LnRleHQuc3Vic3RyaW5nKDAsIDUwKSArICcuLi4nXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBQYXJlbnQgY29tbWVudCBub3QgZm91bmQgZm9yIElEOicsIGNvbW1lbnRJZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNlYXJjaCBmb3IgcmVwbGllcyBkaXJlY3RseSBcbiAgICBjb25zdCB7IGRhdGE6IHJlcGxpZXMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdwYXJlbnRfaWQnLCBjb21tZW50SWQpIC8vIFRoaXMgYXNzdW1lcyBwYXJlbnRfaWQgcmVmZXJlbmNlcyBjb21tZW50X2lkIFxuICAgICAgLm9yZGVyKCdwdWJsaXNoZWRfYXQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyByZXBsaWVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk4ogRm91bmQgJHtyZXBsaWVzPy5sZW5ndGggfHwgMH0gcmVwbGllcyBmb3IgY29tbWVudDpgLCBjb21tZW50SWQpO1xuICAgIFxuICAgIGlmIChyZXBsaWVzICYmIHJlcGxpZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gU2FtcGxlIHRoZSBmaXJzdCByZXBseVxuICAgICAgY29uc29sZS5sb2coJ/CflI0gRmlyc3QgcmVwbHkgc2FtcGxlOicsIHtcbiAgICAgICAgaWQ6IHJlcGxpZXNbMF0uaWQsXG4gICAgICAgIGNvbW1lbnRfaWQ6IHJlcGxpZXNbMF0uY29tbWVudF9pZCxcbiAgICAgICAgcGFyZW50X2lkOiByZXBsaWVzWzBdLnBhcmVudF9pZCxcbiAgICAgICAgdmlkZW9faWQ6IHJlcGxpZXNbMF0udmlkZW9faWQsXG4gICAgICAgIHRleHQ6IHJlcGxpZXNbMF0udGV4dC5zdWJzdHJpbmcoMCwgNTApICsgJy4uLidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYXAgdG8gdGhlIGV4cGVjdGVkIGZvcm1hdFxuICAgIGNvbnN0IHJlcGx5RGF0YSA9IHJlcGxpZXM/Lm1hcChyZXBseSA9PiBtYXBEYkNvbW1lbnRUb0NvbW1lbnREYXRhKHJlcGx5KSkgfHwgW107XG4gICAgXG4gICAgcmV0dXJuIHJlcGx5RGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gZ2V0Q29tbWVudFJlcGxpZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyBHZXQgdmlkZW9zIGZvciBhIGNoYW5uZWxcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDaGFubmVsVmlkZW9zKGNoYW5uZWxJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgLy8gU3RlcCAxOiBHZXQgdGhlIGludGVybmFsIFVVSUQgZm9yIHRoaXMgWW91VHViZSBjaGFubmVsIElEXG4gICAgY29uc3QgeyBkYXRhOiBjaGFubmVsIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NoYW5uZWxzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5lcSgnY2hhbm5lbF9pZCcsIGNoYW5uZWxJZClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDaGFubmVsIG5vdCBmb3VuZCB3aXRoIElEOicsIGNoYW5uZWxJZCk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdGb3VuZCBjaGFubmVsLCBpbnRlcm5hbCBJRDonLCBjaGFubmVsLmlkKTtcbiAgICBcbiAgICAvLyBTdGVwIDI6IFVzZSB0aGUgaW50ZXJuYWwgVVVJRCB0byBxdWVyeSB2aWRlb3NcbiAgICBjb25zdCB7IGRhdGE6IHZpZGVvcywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlkZW9zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdjaGFubmVsX2lkJywgY2hhbm5lbC5pZCk7ICAvLyBVc2luZyBpbnRlcm5hbCBVVUlEIGluc3RlYWQgb2YgWW91VHViZSBjaGFubmVsIElEXG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB2aWRlb3M6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIGlmICghdmlkZW9zIHx8IHZpZGVvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFwIERCIHZpZGVvcyB0byBWaWRlb0RhdGEgZm9ybWF0XG4gICAgY29uc3QgdmlkZW9EYXRhOiBWaWRlb0RhdGFbXSA9IHZpZGVvcy5tYXAodmlkZW8gPT4gKHtcbiAgICAgIGlkOiB2aWRlby52aWRlb19pZCxcbiAgICAgIHRpdGxlOiB2aWRlby50aXRsZSxcbiAgICAgIHB1Ymxpc2hlZEF0OiB2aWRlby5wdWJsaXNoZWRfYXQsXG4gICAgICB0aHVtYm5haWxVcmw6IHZpZGVvLnRodW1ibmFpbF91cmwsXG4gICAgICBjaGFubmVsSWQ6IHZpZGVvLmNoYW5uZWxfaWRcbiAgICB9KSk7XG4gICAgXG4gICAgcmV0dXJuIHZpZGVvRGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDaGFubmVsVmlkZW9zOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gQWRkIHRoaXMgZnVuY3Rpb24gdG8gaW5zcGVjdCBhIGNvbW1lbnQgcmVjb3JkXG5mdW5jdGlvbiBpbnNwZWN0Q29tbWVudChjb21tZW50OiBhbnkpIHtcbiAgY29uc29sZS5sb2coJ0NvbW1lbnQgc3RydWN0dXJlOicsIHtcbiAgICBpZDogY29tbWVudC5pZCxcbiAgICBjb21tZW50X2lkOiBjb21tZW50LmNvbW1lbnRfaWQsXG4gICAgdmlkZW9faWQ6IGNvbW1lbnQudmlkZW9faWQsXG4gICAgcGFyZW50X2lkOiBjb21tZW50LnBhcmVudF9pZCxcbiAgICBjaGFubmVsX2lkOiBjb21tZW50LmNoYW5uZWxfaWQsXG4gICAgLy8gQWRkIG90aGVyIGZpZWxkcyB5b3UgZXhwZWN0XG4gIH0pO1xufVxuXG4vLyBVcGRhdGUgdGhlIGdldENvbW1lbnRUaHJlYWRzIGZ1bmN0aW9uIHdpdGggYWRkaXRpb25hbCBkZWJ1Z2dpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21tZW50VGhyZWFkcyhcbiAgY2hhbm5lbElkOiBzdHJpbmcsIFxuICB2aWRlb0lkPzogc3RyaW5nLCBcbiAgcGFnZTogbnVtYmVyID0gMSwgXG4gIHBlclBhZ2U6IG51bWJlciA9IDIwXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjiBnZXRDb21tZW50VGhyZWFkcyAtIElucHV0czonLCB7IGNoYW5uZWxJZCwgdmlkZW9JZCwgcGFnZSwgcGVyUGFnZSB9KTtcblxuICAgIC8vIFN0ZXAgMTogR2V0IHRoZSBpbnRlcm5hbCBVVUlEIGZvciB0aGlzIFlvdVR1YmUgY2hhbm5lbCBJRFxuICAgIGNvbnN0IHsgZGF0YTogY2hhbm5lbCwgZXJyb3I6IGNoYW5uZWxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjaGFubmVscycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnY2hhbm5lbF9pZCcsIGNoYW5uZWxJZClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBpZiAoY2hhbm5lbEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q29tbWVudFRocmVhZHMgLSBFcnJvciBmaW5kaW5nIGNoYW5uZWw6JywgY2hhbm5lbEVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIGdldENvbW1lbnRUaHJlYWRzIC0gQ2hhbm5lbCBub3QgZm91bmQgd2l0aCBJRDonLCBjaGFubmVsSWQpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pyFIGdldENvbW1lbnRUaHJlYWRzIC0gRm91bmQgY2hhbm5lbDonLCB7IFxuICAgICAgaW50ZXJuYWxfaWQ6IGNoYW5uZWwuaWQsIFxuICAgICAgY2hhbm5lbF9pZDogY2hhbm5lbC5jaGFubmVsX2lkLFxuICAgICAgdGl0bGU6IGNoYW5uZWwudGl0bGVcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTdGVwIDI6IFVzZSB0aGUgaW50ZXJuYWwgVVVJRCB0byBxdWVyeSBjb21tZW50c1xuICAgIGNvbnN0IHN0YXJ0SWR4ID0gKHBhZ2UgLSAxKSAqIHBlclBhZ2U7XG4gICAgY29uc3QgZW5kSWR4ID0gcGFnZSAqIHBlclBhZ2UgLSAxO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SiIGdldENvbW1lbnRUaHJlYWRzIC0gUmFuZ2U6ICR7c3RhcnRJZHh9IHRvICR7ZW5kSWR4fWApO1xuICAgIFxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY29tbWVudHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NoYW5uZWxfaWQnLCBjaGFubmVsLmlkKVxuICAgICAgLmlzKCdwYXJlbnRfaWQnLCBudWxsKSAvLyBPbmx5IGdldCB0b3AtbGV2ZWwgY29tbWVudHNcbiAgICAgIC5vcmRlcigncHVibGlzaGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAucmFuZ2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gICAgXG4gICAgaWYgKHZpZGVvSWQpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3ZpZGVvX2lkJywgdmlkZW9JZCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YTogY29tbWVudHMsIGVycm9yOiBjb21tZW50c0Vycm9yIH0gPSBhd2FpdCBxdWVyeTtcbiAgICBcbiAgICBpZiAoY29tbWVudHNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldENvbW1lbnRUaHJlYWRzIC0gRXJyb3IgZmV0Y2hpbmcgY29tbWVudHM6JywgY29tbWVudHNFcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5OKIGdldENvbW1lbnRUaHJlYWRzIC0gRm91bmQgJHtjb21tZW50cz8ubGVuZ3RoIHx8IDB9IGNvbW1lbnRzYCk7XG4gICAgXG4gICAgaWYgKCFjb21tZW50cyB8fCBjb21tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2FtcGxlIHRoZSBmaXJzdCBjb21tZW50IHRvIGRlYnVnXG4gICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIGdldENvbW1lbnRUaHJlYWRzIC0gRmlyc3QgY29tbWVudDonLCB7XG4gICAgICAgIGlkOiBjb21tZW50c1swXS5pZCxcbiAgICAgICAgY29tbWVudF9pZDogY29tbWVudHNbMF0uY29tbWVudF9pZCxcbiAgICAgICAgcGFyZW50X2lkOiBjb21tZW50c1swXS5wYXJlbnRfaWQsXG4gICAgICAgIGNoYW5uZWxfaWQ6IGNvbW1lbnRzWzBdLmNoYW5uZWxfaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3IgZWFjaCBjb21tZW50LCBjb3VudCByZXBsaWVzIGFuZCBtYXAgdG8gQ29tbWVudERhdGEgZm9ybWF0XG4gICAgY29uc3QgY29tbWVudERhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGNvbW1lbnRzLm1hcChhc3luYyAoY29tbWVudCkgPT4ge1xuICAgICAgICAvLyBDb3VudCByZXBsaWVzIGZvciB0aGlzIGNvbW1lbnQgXG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5lcSgncGFyZW50X2lkJywgY29tbWVudC5jb21tZW50X2lkKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlcGx5Q291bnQgPSBjb3VudCB8fCAwO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFwIERCIGNvbW1lbnQgdG8gQ29tbWVudERhdGEgZm9ybWF0IHdpdGggcmVwbHkgY291bnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5tYXBEYkNvbW1lbnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpLFxuICAgICAgICAgIHJlcGx5Q291bnRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gY29tbWVudERhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldENvbW1lbnRUaHJlYWRzIC0gVW5oYW5kbGVkIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNvbW1lbnRSZXBseUNvdW50cygpIHtcbiAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHJlcGx5IGNvdW50cyBmb3IgYWxsIGNvbW1lbnRzLi4uJyk7XG4gIFxuICB0cnkge1xuICAgIC8vIEZvciBlYWNoIGNvbW1lbnQgd2l0aCByZXBsaWVzLCBjb3VudCB0aGVtIGFuZCB1cGRhdGUgdGhlIHJlcGx5X2NvdW50XG4gICAgY29uc3QgeyBkYXRhOiBjb21tZW50cyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb21tZW50cycpXG4gICAgICAuc2VsZWN0KCdjb21tZW50X2lkJylcbiAgICAgIC5pcygncGFyZW50X2lkJywgbnVsbCk7XG4gICAgXG4gICAgaWYgKCFjb21tZW50cykgcmV0dXJuO1xuICAgIFxuICAgIGZvciAoY29uc3QgY29tbWVudCBvZiBjb21tZW50cykge1xuICAgICAgLy8gQ291bnQgdGhlIHJlcGxpZXMgZm9yIHRoaXMgY29tbWVudFxuICAgICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NvbW1lbnRzJylcbiAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgLmVxKCdwYXJlbnRfaWQnLCBjb21tZW50LmNvbW1lbnRfaWQpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIHJlcGx5X2NvdW50XG4gICAgICBpZiAoY291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdjb21tZW50cycpXG4gICAgICAgICAgLnVwZGF0ZSh7IHJlcGx5X2NvdW50OiBjb3VudCB9KVxuICAgICAgICAgIC5lcSgnY29tbWVudF9pZCcsIGNvbW1lbnQuY29tbWVudF9pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdSZXBseSBjb3VudHMgdXBkYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByZXBseSBjb3VudHM6JywgZXJyb3IpO1xuICB9XG59ICJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsImRlY29kZUFsbEh0bWxFbnRpdGllcyIsInNlYXJjaEZvckNoYW5uZWwiLCJjaGFubmVsTmFtZSIsImFwaUtleSIsInVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsIml0ZW1zIiwibGVuZ3RoIiwiRXJyb3IiLCJpZCIsImNoYW5uZWxJZCIsImZldGNoVmlkZW9zQnlDaGFubmVsIiwibWF4UmVzdWx0cyIsInBhZ2VUb2tlbiIsImZldGNoQWxsVmlkZW9zQnlDaGFubmVsIiwiYWxsVmlkZW9zIiwibmV4dFBhZ2VUb2tlbiIsImNvbnNvbGUiLCJsb2ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmZXRjaENvbW1lbnRzIiwidmlkZW9JZCIsIm9rIiwic3RhdHVzVGV4dCIsImVycm9yIiwiZmV0Y2hMYXRlc3RDaGFubmVsQ29tbWVudHMiLCJtYXhWaWRlb3MiLCJpbmNsdWRlT2xkVmlkZW9zIiwibWF4Q29tbWVudHMiLCJpbmNsdWRlUmVwbGllcyIsInZpZGVvc1Jlc3BvbnNlIiwicHJvY2Vzc2VkVmlkZW9zIiwic2xpY2UiLCJhbGxDb21tZW50cyIsInRvdGFsQ29tbWVudHNBZGRlZCIsInZpZGVvIiwicmVzb3VyY2VJZCIsInZpZGVvVGl0bGUiLCJzbmlwcGV0IiwidGl0bGUiLCJjb21tZW50cyIsImNvbW1lbnROZXh0UGFnZVRva2VuIiwiY29tbWVudFBhZ2VzIiwiY29tbWVudFJlc3BvbnNlIiwidmlkZW9Db21tZW50cyIsImNvbW1lbnQiLCJlbnJpY2hlZENvbW1lbnQiLCJwdXNoIiwicmVwbGllcyIsInJlcGx5IiwicmVwbHlDb21tZW50IiwidG9wTGV2ZWxDb21tZW50IiwicGFyZW50SWQiLCJnZXRDb21tZW50c0ZvclZpZGVvIiwiY29tbWVudENvdW50IiwibWFwWW91VHViZUNvbW1lbnRUb0RiQ29tbWVudCIsInR5cGUiLCJjb21tZW50X2lkIiwidmlkZW9faWQiLCJhdXRob3JfbmFtZSIsImF1dGhvckRpc3BsYXlOYW1lIiwiYXV0aG9yX3Byb2ZpbGVfdXJsIiwiYXV0aG9yUHJvZmlsZUltYWdlVXJsIiwidGV4dCIsInRleHREaXNwbGF5IiwibGlrZV9jb3VudCIsImxpa2VDb3VudCIsInB1Ymxpc2hlZF9hdCIsInB1Ymxpc2hlZEF0IiwiY2hhbm5lbF9pZCIsImlzX293bmVyX2NvbW1lbnQiLCJwYXJlbnRfaWQiLCJ2aWRlb190aXRsZSIsIm1hcERiQ29tbWVudFRvQ29tbWVudERhdGEiLCJkYkNvbW1lbnQiLCJ1cGRhdGVkQXQiLCJ1cGRhdGVkX2F0IiwicmVwbHlDb3VudCIsInJlcGx5X2NvdW50IiwiaXNIZWFydGVkQnlDcmVhdG9yIiwiaXNQaW5uZWQiLCJsb2dBbGxQYXJlbnRDaGlsZFJlbGF0aW9uc2hpcHMiLCJmcm9tIiwic2VsZWN0Iiwibm90IiwibGltaXQiLCJ0aGVuIiwiZ2V0Q29tbWVudFJlcGxpZXMiLCJjb21tZW50SWQiLCJyZXBseUNoZWNrIiwicmVwbHlDaGVja0Vycm9yIiwiZXEiLCJzaW5nbGUiLCJwYXJlbnRDb21tZW50IiwicGFyZW50RXJyb3IiLCJzdWJzdHJpbmciLCJvcmRlciIsImFzY2VuZGluZyIsInJlcGx5RGF0YSIsIm1hcCIsImdldENoYW5uZWxWaWRlb3MiLCJjaGFubmVsIiwidmlkZW9zIiwidmlkZW9EYXRhIiwidGh1bWJuYWlsVXJsIiwidGh1bWJuYWlsX3VybCIsImluc3BlY3RDb21tZW50IiwiZ2V0Q29tbWVudFRocmVhZHMiLCJwYWdlIiwicGVyUGFnZSIsImNoYW5uZWxFcnJvciIsImludGVybmFsX2lkIiwic3RhcnRJZHgiLCJlbmRJZHgiLCJxdWVyeSIsImlzIiwicmFuZ2UiLCJjb21tZW50c0Vycm9yIiwiY29tbWVudERhdGEiLCJhbGwiLCJjb3VudCIsImhlYWQiLCJ1cGRhdGVDb21tZW50UmVwbHlDb3VudHMiLCJ1bmRlZmluZWQiLCJ1cGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/youtube.ts\n"));

/***/ })

});